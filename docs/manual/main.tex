%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LUMINA-SN Technical Manual
% Based on The Legrand Orange Book Template
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[11pt,fleqn]{book}

\input{structure}

\begin{document}

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\begingroup
\thispagestyle{empty}
\begin{tikzpicture}[remember picture,overlay]
\coordinate [below=12cm] (midpoint) at (current page.north);
\node at (current page.north west)
{\begin{tikzpicture}[remember picture,overlay]
\fill[ocre!20] (0,0) rectangle (\paperwidth,-\paperheight);
\fill[ocre] (0,0) rectangle (\paperwidth,-4cm);
\fill[darkblue] (0,-4cm) rectangle (\paperwidth,-4.3cm);
\draw[anchor=north] (midpoint) node [fill=white,fill opacity=0.85,text opacity=1,inner sep=1.5cm,rounded corners=3pt]{
\Huge\centering\bfseries\sffamily\parbox[c][][t]{0.85\paperwidth}{\centering
\textcolor{darkblue}{LUMINA-SN}\\[15pt]
{\Large\textcolor{ocre}{Monte Carlo Radiative Transfer for Type Ia Supernovae}}\\[8pt]
{\large A Complete Technical Manual}\\[25pt]
{\large Professor Juhan Kim}\\[5pt]
{\normalsize February 2026}
}};
\end{tikzpicture}};
\end{tikzpicture}
\vfill
\endgroup

%----------------------------------------------------------------------------------------
%	COPYRIGHT PAGE
%----------------------------------------------------------------------------------------

\newpage
~\vfill
\thispagestyle{empty}

\noindent Copyright \copyright\ 2026 Juhan Kim\\

\noindent \textsc{LUMINA-SN: Luminosity-driven Monte Carlo Supernova Spectral Synthesizer}\\

\noindent This code implements 1D Monte Carlo radiative transfer in homologously expanding supernova ejecta, following the formalism of \citet{lucy1999a,lucy2002,lucy2003} and the TARDIS code \citep{kerzendorf2014}. Written in C99 with CUDA GPU acceleration.\\

\noindent \textit{Version 2.0 --- February 2026}

%----------------------------------------------------------------------------------------
%	TABLE OF CONTENTS
%----------------------------------------------------------------------------------------

\pagestyle{empty}
\tableofcontents
\cleardoublepage
\pagestyle{fancy}

%========================================================================================
%	PART I: PHYSICS & THEORY
%========================================================================================

\part{Physics \& Theory}

%----------------------------------------------------------------------------------------
%	CHAPTER 1: Introduction
%----------------------------------------------------------------------------------------

\chapter{Introduction to Type Ia Supernovae}\index{Type Ia Supernovae}

\section{What is a Type Ia Supernova?}

A Type Ia supernova (SN~Ia) is the thermonuclear explosion of a carbon-oxygen white dwarf star that has reached a critical mass near the Chandrasekhar limit ($M_\mathrm{Ch} \approx 1.4\,M_\odot$). The explosion completely unbinds the star, leaving no compact remnant, and synthesizes approximately $0.6\,M_\odot$ of radioactive $^{56}$Ni \citep{nomoto1984}.

\begin{important}
SN~Ia are cosmological standard candles: their peak luminosity correlates with their light-curve decline rate (the Phillips relation, \citealt{phillips1993}), enabling precise distance measurements to galaxies. This led to the discovery of the accelerating expansion of the Universe.
\end{important}

\section{The Expanding Ejecta}\index{Ejecta!Homologous Expansion}

After the explosion, the ejecta expand freely into a vacuum. Within hours, the expansion reaches a state of \textbf{homologous expansion}:
\begin{equation}
\boxed{v(r, t) = \frac{r}{t}}
\label{eq:homologous}
\end{equation}
where $r$ is the radial distance from the center and $t$ is the time since explosion. This means velocity maps directly to radius: faster material is farther out.

\begin{definition}[Homologous Expansion]
In homologous expansion, each fluid element moves at constant velocity. The density at any velocity coordinate $v$ evolves as:
\begin{equation}
\rho(v, t) = \rho_0(v) \left(\frac{t_0}{t}\right)^3
\end{equation}
where $\rho_0(v)$ is the density at reference epoch $t_0$, and the $t^{-3}$ factor comes from the 3D volumetric dilution.
\end{definition}

\section{Spectral Features}\index{Spectral Features}

SN~Ia spectra are dominated by \textbf{P~Cygni profiles}: blueshifted absorption troughs paired with redshifted emission peaks. These arise because:

\begin{enumerate}
\item Material approaching the observer (along the line of sight) absorbs photons at a blueshifted wavelength.
\item The surrounding envelope re-emits photons isotropically, producing a net emission component redward of the rest wavelength.
\end{enumerate}

\begin{table}[h]
\centering
\caption{Key spectral features in SN~Ia near maximum light.}
\label{tab:spectral_features}
\begin{tabular}{llll}
\toprule
\textbf{Ion} & \textbf{Rest $\lambda$ (\AA)} & \textbf{Observed Range (\AA)} & \textbf{Diagnostic Value} \\
\midrule
Si~\textsc{ii} & 6355 & 5800--6500 & Expansion velocity, temperature \\
Si~\textsc{ii} & 5972 & 5600--6000 & Temperature indicator \\
S~\textsc{ii}  & 5454, 5640 & 5200--5700 & ``W'' feature, burning completeness \\
Ca~\textsc{ii} & 3934, 3968 & 3600--4000 & H\&K lines, high-velocity features \\
Ca~\textsc{ii} & 8498, 8542, 8662 & 8000--8800 & IR triplet \\
Fe~\textsc{ii} & 4500--5200 & 4300--5200 & Iron-group blanketing \\
O~\textsc{i}   & 7774 & 7400--7900 & Unburned oxygen indicator \\
\bottomrule
\end{tabular}
\end{table}

\section{The Inverse Problem}

Given an observed spectrum, we want to determine the physical parameters of the explosion:
\begin{itemize}
\item Luminosity $L$ and photospheric temperature $T_\mathrm{inner}$
\item Density profile $\rho(v)$ and its power-law exponents
\item Chemical composition as a function of velocity (abundance tomography)
\item Time since explosion $t_\mathrm{exp}$
\end{itemize}

LUMINA-SN solves the \emph{forward problem}: given these parameters, compute the emergent spectrum. Combined with Bayesian inference (Part~III), this enables solving the inverse problem.


%----------------------------------------------------------------------------------------
%	CHAPTER 2: Radiative Transfer Theory
%----------------------------------------------------------------------------------------

\chapter{Radiative Transfer in Expanding Atmospheres}\index{Radiative Transfer}

\section{The Transfer Equation}\index{Transfer Equation}

The specific intensity $I_\nu$ along a ray satisfies:
\begin{equation}
\frac{dI_\nu}{ds} = -\kappa_\nu \, I_\nu + j_\nu
\label{eq:rte}
\end{equation}
where $s$ is the path length, $\kappa_\nu$ is the absorption coefficient (opacity), and $j_\nu$ is the emissivity.

In a supernova atmosphere, three opacity sources contribute:
\begin{enumerate}
\item \textbf{Electron scattering} (Thomson): frequency-independent, $\sigma_T = 6.652 \times 10^{-25}$~cm$^2$
\item \textbf{Line opacity} (Sobolev): resonant absorption in atomic transitions
\item \textbf{Continuum opacity}: bound--free and free--free (negligible in SN~Ia, see \S\ref{sec:bfff})
\end{enumerate}

\section{The Sobolev Approximation}\index{Sobolev Approximation}

In homologous expansion, the velocity gradient $dv/dr = 1/t_\mathrm{exp}$ is constant. A photon sweeps through a line's resonance frequency over a very short distance (the \emph{Sobolev length}). This means line interactions are \emph{local}: each line either absorbs the photon or lets it pass.

\begin{definition}[Sobolev Optical Depth]\index{Sobolev Optical Depth}
The optical depth of a line transition $l \to u$ in the Sobolev approximation is:
\begin{equation}
\boxed{\tau_\mathrm{Sob} = \frac{\pi e^2}{m_e c} \, f_{lu} \, \lambda_0 \, t_\mathrm{exp} \, n_l \left(1 - \frac{g_l \, n_u}{g_u \, n_l}\right)}
\label{eq:tau_sobolev}
\end{equation}
where $f_{lu}$ is the oscillator strength, $\lambda_0$ is the rest wavelength, $n_l$ and $n_u$ are the lower and upper level populations, and $g_l$, $g_u$ are the statistical weights.
\end{definition}

The numerical coefficient is:
\begin{equation}
\frac{\pi e^2}{m_e c} = 0.02654 \;\text{cm}^2\,\text{s}^{-1} \quad\text{(CGS)}
\end{equation}

The \emph{escape probability} from a Sobolev line is:
\begin{equation}
\beta_\mathrm{Sob} = \frac{1 - e^{-\tau_\mathrm{Sob}}}{\tau_\mathrm{Sob}}
\end{equation}

\section{The Dilute Radiation Field}\index{Dilution Factor}

Far from the photosphere, the radiation field is diluted. The mean intensity is:
\begin{equation}
J_\nu = W \, B_\nu(T_\mathrm{rad})
\end{equation}
where $W$ is the \textbf{dilution factor} and $T_\mathrm{rad}$ is the \textbf{radiation temperature}. For a geometrically thin photosphere at radius $R_\mathrm{phot}$:
\begin{equation}
W(r) = \frac{1}{2}\left(1 - \sqrt{1 - \left(\frac{R_\mathrm{phot}}{r}\right)^2}\right)
\label{eq:W_geometric}
\end{equation}

\begin{remark}[Physical Interpretation of $W$]
At $r = R_\mathrm{phot}$: $W = 0.5$ (hemisphere illuminated). At $r \gg R_\mathrm{phot}$: $W \approx R_\mathrm{phot}^2 / (4r^2) \to 0$ (point source). In practice, Monte Carlo estimators yield $W$ values that include the effects of line scattering and fluorescence.
\end{remark}

\section{Frame Transformations}\index{Doppler!Frame Transformations}

In homologous expansion, the comoving-frame (CMF) frequency differs from the lab-frame frequency:
\begin{equation}
\nu_\mathrm{cmf} = \nu_\mathrm{lab} \, \left(1 - \frac{\mu \, v}{c}\right) = \nu_\mathrm{lab} \, \left(1 - \frac{\mu \, r}{c \, t_\mathrm{exp}}\right)
\label{eq:doppler}
\end{equation}
where $\mu = \cos\theta$ is the direction cosine of the photon with respect to the radial direction, and $v = r/t_\mathrm{exp}$.

\begin{important}
As a photon propagates through a shell, the comoving-frame frequency changes \emph{linearly} with distance $s$ along the ray:
\begin{equation}
\nu_\mathrm{cmf}(s) = \nu_\mathrm{lab} \left(1 - \frac{r_0\,\mu_0 + s}{c\,t_\mathrm{exp}}\right)
\end{equation}
This monotonic frequency sweep is the basis of the Sobolev sweep algorithm (\S\ref{sec:sobolev_sweep}).
\end{important}

\section{Bound--Free and Free--Free Opacity}\label{sec:bfff}\index{Continuum Opacity}

In SN~Ia ejecta, continuum opacities are negligible because:
\begin{itemize}
\item \textbf{Bound--free}: Optical photons (1.5--2.5~eV) are far below the ionization thresholds of the dominant species (Si~\textsc{ii}: 16.35~eV, Fe~\textsc{ii}: 16.19~eV, Ca~\textsc{ii}: 11.87~eV). Only far-UV photons ($< 1000$~\AA) could ionize these ions.
\item \textbf{Free--free}: Electron densities are very low ($n_e \sim 10^9$~cm$^{-3}$ inner, $\sim 10^6$~cm$^{-3}$ outer), giving $\kappa_\mathrm{ff} \sim 10^{-20}$~cm$^{-1}$.
\end{itemize}

The combined continuum optical depth across a shell is $\tau_\mathrm{cont} \sim 10^{-6}$ to $10^{-9}$, confirming that \textbf{line opacity dominates} the spectrum formation in SN~Ia.


%----------------------------------------------------------------------------------------
%	CHAPTER 3: Monte Carlo Methods
%----------------------------------------------------------------------------------------

\chapter{Monte Carlo Photon Transport}\index{Monte Carlo Methods}

\section{The Indivisible Energy Packet Formalism}\index{Energy Packets}

LUMINA follows the \citet{lucy1999a,lucy2002} formalism, where photons are represented as discrete \textbf{energy packets} ($r$-packets) with properties:

\begin{table}[h]
\centering
\caption{Properties of an $r$-packet in LUMINA.}
\begin{tabular}{lll}
\toprule
\textbf{Symbol} & \textbf{Description} & \textbf{Unit} \\
\midrule
$r$ & Radial position & cm \\
$\mu$ & Direction cosine ($\cos\theta$) & -- \\
$\nu$ & Lab-frame frequency & Hz \\
$\varepsilon$ & Packet energy & erg \\
$i_\mathrm{shell}$ & Current shell index & -- \\
\bottomrule
\end{tabular}
\end{table}

All packets carry the same energy:
\begin{equation}
\varepsilon_\mathrm{pkt} = \frac{L_\mathrm{inner} \, \Delta t}{N_\mathrm{packets}}
\end{equation}
where $L_\mathrm{inner}$ is the luminosity at the inner boundary and $\Delta t$ is the simulation time interval.

\section{Packet Initialization}\index{Packet Initialization}

Packets are emitted from the photosphere ($r = R_\mathrm{inner}$) with:

\subsection{Frequency Sampling from the Planck Function}

The emission frequency is sampled from a blackbody at temperature $T_\mathrm{inner}$ using the \citet{bjorkman2001} method:

\begin{enumerate}
\item Draw $\xi_0 \sim U(0,1)$
\item Find $l_\mathrm{min}$ such that $\displaystyle\sum_{i=1}^{l_\mathrm{min}} i^{-4} \geq \frac{\pi^4}{90}\,\xi_0$
\item Draw $\xi_1, \xi_2, \xi_3, \xi_4 \sim U(0,1)$
\item Compute $x = -\ln(\xi_1 \xi_2 \xi_3 \xi_4) / l_\mathrm{min}$
\item Set $\nu = x \, k_B T_\mathrm{inner} / h$
\end{enumerate}

This is exact (no rejection) and samples directly from $B_\nu(T)$.

\subsection{Angular Distribution}

The direction cosine is sampled from a limb-darkened distribution:
\begin{equation}
\mu = \sqrt{\xi}, \quad \xi \sim U(0,1)
\end{equation}
ensuring that more packets are emitted along the normal direction.

\section{The Packet Propagation Loop}\label{sec:propagation}\index{Propagation Loop}

Each packet undergoes a loop until it escapes ($r > R_\mathrm{outer}$) or is reabsorbed ($r < R_\mathrm{inner}$ moving inward):

\begin{ocrebox}
\textbf{Algorithm: Single Packet Loop}
\begin{enumerate}
\item \textbf{Draw random optical depth}: $\tau_\mathrm{event} = -\ln(\xi)$
\item \textbf{Compute distances} to possible events:
  \begin{itemize}
  \item $d_\mathrm{boundary}$: distance to next shell wall
  \item $d_\mathrm{line}$: distance to next Sobolev resonance
  \item $d_\mathrm{e}$: distance to electron scattering ($\tau = n_e \sigma_T d$)
  \end{itemize}
\item \textbf{Select minimum}: $d_\mathrm{min} = \min(d_\mathrm{boundary}, d_\mathrm{line}, d_\mathrm{e})$
\item \textbf{Move packet}: update $r$, $\mu$, accumulate estimators
\item \textbf{Handle interaction}:
  \begin{itemize}
  \item Boundary: change shell, check escape/reabsorption
  \item Line: scatter, downbranch, or activate macro-atom
  \item Electron: Thomson scatter (isotropic re-emission)
  \end{itemize}
\item \textbf{Repeat} from step 1
\end{enumerate}
\end{ocrebox}

\section{Distance Calculations}\index{Distance Calculations}

\subsection{Distance to Shell Boundary}

For a packet at $(r, \mu)$ in shell $[r_\mathrm{in}, r_\mathrm{out}]$:

\textbf{Outward} ($\mu > 0$ or $r > r_\mathrm{in}/\mu$):
\begin{equation}
d_\mathrm{out} = \sqrt{r_\mathrm{out}^2 - r^2(1 - \mu^2)} - r\mu
\end{equation}

\textbf{Inward} ($\mu < 0$ and impact parameter $< r_\mathrm{in}$):
\begin{equation}
d_\mathrm{in} = -r\mu - \sqrt{r_\mathrm{in}^2 - r^2(1 - \mu^2)}
\end{equation}

\subsection{Distance to Electron Scattering}

\begin{equation}
d_e = \frac{\tau_\mathrm{event}}{n_e \, \sigma_T}
\end{equation}

\subsection{Distance to Sobolev Resonance}\label{sec:sobolev_sweep}\index{Sobolev Sweep}

As the packet traverses the shell, the CMF frequency sweeps through the line list. For a line at rest frequency $\nu_\mathrm{line}$:

\begin{equation}
d_\mathrm{line} = \frac{\nu_\mathrm{cmf}(r, \mu) - \nu_\mathrm{line}}{\nu_\mathrm{lab}} \, c \, t_\mathrm{exp}
\label{eq:d_line}
\end{equation}

\begin{important}
The Sobolev sweep must scan from the \emph{entry} frequency to the \emph{exit} frequency of each shell. The original LUMINA code used a fixed $\pm 1\%$ window, which missed lines during thick shell crossings. The corrected algorithm (Task \#067) uses the full Doppler sweep, increasing line interactions from 0.6\% to $>50\%$ of packet steps.
\end{important}

\section{Line Interaction Types}\index{Line Interactions}

When a packet encounters a line, three interaction modes are available:

\subsection{Resonant Scattering (Mode 0)}\index{Line Interactions!Resonant Scattering}
The packet is absorbed and re-emitted at the same line frequency with a new random direction:
\begin{equation}
\mu_\mathrm{new} \sim U(-1, +1), \quad \nu_\mathrm{new} = \nu_\mathrm{line}
\end{equation}

\subsection{Downbranching (Mode 1)}\index{Line Interactions!Downbranching}
The packet is absorbed into the upper level and re-emitted in a \emph{different} line, selected from the downbranching probability distribution:
\begin{equation}
P(\text{emit in line } j) = \frac{A_{u \to l_j}}{\sum_k A_{u \to l_k}}
\end{equation}
This enables fluorescence: a UV photon absorbed in one line can be re-emitted in the optical.

\subsection{Macro-Atom (Mode 2)}\index{Line Interactions!Macro-Atom}\index{Macro-Atom}

The full macro-atom formalism \citep{lucy2002,lucy2003} activates the atom at the upper energy level and follows a Markov chain of internal transitions:

\begin{ocrebox}
\textbf{Algorithm: Macro-Atom Transition Walk}
\begin{enumerate}
\item Start at activation level $l$
\item Look up transition block for level $l$ (list of possible transitions)
\item Draw $\xi \sim U(0,1)$, select transition $k$ from cumulative probabilities
\item If transition type $\geq 0$ (internal): move to destination level, go to step 2
\item If transition type $< 0$ (emission): emit in the associated line, \textbf{exit}
\end{enumerate}
Maximum 500 iterations (safety limit).
\end{ocrebox}

Emission types include:
\begin{itemize}
\item $-1$: Bound--bound emission (emit photon in a specific line)
\item $-2$: Bound--free emission (photoionization, thermalization)
\item $-3$: Free--free emission (thermal)
\item $-4$: Adiabatic cooling
\end{itemize}

\section{Monte Carlo Estimators}\index{Estimators}

As packets propagate, they contribute to estimators that probe the radiation field.

\begin{definition}[Mean Intensity Estimator]\index{Estimators!Mean Intensity}
\begin{equation}
\hat{J}_\nu = \frac{1}{4\pi \, V \, \Delta t} \sum_\mathrm{packets} \varepsilon_\mathrm{cmf} \, \Delta s
\end{equation}
In practice, two scalar estimators are accumulated per shell:
\begin{align}
j &= \sum_\mathrm{packets} \varepsilon_\mathrm{cmf} \, \Delta s \label{eq:j_est} \\
\overline{\nu} &= \frac{\sum_\mathrm{packets} \varepsilon_\mathrm{cmf} \, \nu_\mathrm{cmf} \, \Delta s}{\sum_\mathrm{packets} \varepsilon_\mathrm{cmf} \, \Delta s} \label{eq:nubar_est}
\end{align}
\end{definition}

From these, the radiation temperature and dilution factor are recovered:
\begin{align}
T_\mathrm{rad} &= T_\mathrm{rad,const} \times \frac{\bar{\nu}}{j} \label{eq:Trad_from_est} \\[4pt]
W &= \frac{j}{4\,\sigma_\mathrm{SB}\,T_\mathrm{rad}^4\,\Delta t\,V} \label{eq:W_from_est}
\end{align}
where $T_\mathrm{rad,const} = \frac{\pi^4}{15 \cdot 24 \cdot \zeta(5)} \frac{h}{k_B} = 1.2523 \times 10^{-11}$~K$\cdot$s.

\section{Convergence: The Iteration Loop}\index{Convergence}

LUMINA iterates between transport and plasma calculations:

\begin{enumerate}
\item \textbf{Transport}: Run $N_\mathrm{packets}$ through the ejecta, accumulating estimators.
\item \textbf{Radiation field update}: Compute $T_\mathrm{rad}$, $W$ from estimators, with \textbf{damping}:
\begin{equation}
X_\mathrm{new} = X_\mathrm{old} + d \cdot (X_\mathrm{est} - X_\mathrm{old}), \quad d = 0.5
\end{equation}
\item \textbf{Plasma update}: Recompute ionization, level populations, $\tau_\mathrm{Sob}$.
\item \textbf{$T_\mathrm{inner}$ update} (after hold iterations):
\begin{equation}
\boxed{T_\mathrm{inner,new} = T_\mathrm{inner,old} + d \cdot \left[T_\mathrm{inner} \left(\frac{L_\mathrm{emitted}}{L_\mathrm{requested}}\right)^{-0.5} - T_\mathrm{inner,old}\right]}
\label{eq:t_inner_update}
\end{equation}
\end{enumerate}

\begin{remark}[Exponent $-0.5$ vs $+0.25$]
Na\"ively, Stefan--Boltzmann gives $T \propto L^{0.25}$, suggesting the correction factor should be $(L_\mathrm{em}/L_\mathrm{req})^{0.25}$. However, TARDIS uses the exponent $-0.5$ because changing $T_\mathrm{inner}$ also changes the opacity (through ionization), leading to non-linear feedback. The empirical $-0.5$ accounts for this.
\end{remark}


%----------------------------------------------------------------------------------------
%	CHAPTER 4: Spectrum Synthesis Methods
%----------------------------------------------------------------------------------------

\chapter{Spectrum Synthesis Methods}\index{Spectrum Synthesis}

LUMINA implements three distinct methods for constructing the emergent spectrum from the Monte Carlo simulation. Each method makes different trade-offs between physical fidelity, noise characteristics, and computational cost.

\section{Overview of the Three Methods}

\begin{table}[h]
\centering
\caption{Comparison of the three spectrum synthesis methods.}
\label{tab:spectrum_methods}
\small
\begin{tabular}{lccc}
\toprule
\textbf{Property} & \textbf{Real Packet} & \textbf{Virtual Packet} & \textbf{Rotation Packet} \\
\midrule
Transport type & Full Monte Carlo & Formal integral (ray tracing) & Post-processing \\
Cost per real packet & 1$\times$ (baseline) & $+10\times$ (per interaction) & Negligible \\
Noise & $\propto N^{-1/2}$ & Lower (many rays) & Same as real \\
Observer direction & Angle-averaged & Angle-averaged & Direction-dependent \\
Hardware & CPU + GPU & GPU only & CPU + GPU \\
Output file & \texttt{spectrum.csv} & \texttt{spectrum\_virtual.csv} & \texttt{spectrum\_rotation.csv} \\
\bottomrule
\end{tabular}
\end{table}


\section{Real Packets}\label{sec:real_packets}\index{Spectrum Synthesis!Real Packets}

The \textbf{real packet} method is the standard Monte Carlo approach. It is the simplest, most robust, and provides the estimators ($j$, $\bar\nu$) needed for convergence.

\subsection{Principle}

Each energy packet is launched from the photosphere, undergoes a random walk through the ejecta (line scattering, electron scattering, boundary crossings), and eventually either escapes through the outer boundary or is reabsorbed at the inner boundary. The emergent spectrum is constructed by \emph{binning} the escaped packets:

\begin{equation}
L_\lambda(\lambda_k) = \frac{1}{\Delta\lambda} \sum_{\substack{p \in \mathrm{escaped} \\ \lambda_p \in [\lambda_k, \lambda_k + \Delta\lambda)}} \varepsilon_p
\end{equation}
where $\varepsilon_p$ is the packet energy and $\lambda_p = c / \nu_p$ is its escape wavelength.

\subsection{Algorithm}

\begin{ocrebox}
\textbf{Algorithm: Real Packet Spectrum}
\begin{enumerate}
\item Launch $N$ packets from $r = R_\mathrm{inner}$ with blackbody frequency, $\mu = \sqrt{\xi}$
\item For each packet: trace through ejecta until escape or reabsorption (see \S\ref{sec:propagation})
\item Accumulate $j$ and $\bar\nu$ estimators at each step (for convergence)
\item For escaped packets: store $(\nu_\mathrm{lab}, \varepsilon)$ and bin into spectrum
\item Compute $L_\mathrm{emitted} = \sum_\mathrm{escaped} \varepsilon_p$ for $T_\mathrm{inner}$ update
\end{enumerate}
\end{ocrebox}

\subsection{Strengths and Limitations}

\begin{itemize}
\item[\textbf{+}] Self-consistent: the same packets drive both the spectrum \emph{and} the convergence loop
\item[\textbf{+}] Captures all non-linear transport effects (multiple scatterings, fluorescence)
\item[\textbf{+}] Available on both CPU and GPU
\item[\textbf{--}] High Monte Carlo noise in wavelength bins with few packets (deep absorption troughs)
\item[\textbf{--}] Angle-averaged: no directional information preserved
\end{itemize}


\section{Virtual Packets}\label{sec:virtual_packets}\index{Spectrum Synthesis!Virtual Packets}\index{Virtual Packets}

The \textbf{virtual packet} method implements a formal-integral ray-tracing approach inspired by TARDIS \citep{kerzendorf2014}. At every interaction point of a real packet, $N_v$ virtual packets are emitted in random directions and passively traced through the remaining ejecta to compute their escape probability.

\subsection{Physical Motivation}

Consider a real packet that has just undergone a line scattering event at position $(r, \hat{n})$ in shell $s$, emitting a photon at comoving frequency $\nu_\mathrm{cmf}$. The question is: what fraction of this radiation escapes the ejecta along a given direction? Rather than relying on the single random walk of the real packet, virtual packets evaluate this explicitly by integrating the optical depth along rays:

\begin{equation}
\boxed{P_\mathrm{esc}(\hat{n}) = \exp\left(-\int_0^\infty \kappa(s)\,ds\right) = \exp\left(-\tau_\mathrm{total}\right)}
\label{eq:vpacket_escape}
\end{equation}

The key insight is that this integral can be evaluated \emph{deterministically} (no random interactions), making it much cheaper per ray than full Monte Carlo transport.

\subsection{The $p$-$z$ Coordinate System}\index{Virtual Packets!p-z Coordinates}

Virtual packets are traced in the $(p, z)$ coordinate system, where $p$ is the \textbf{impact parameter} (perpendicular distance from the ray to the center) and $z$ is the coordinate along the ray:

\begin{align}
p &= r\,\sqrt{1 - \mu_v^2} & &\text{(constant along the ray)} \\
z &= r\,\mu_v & &\text{(varies as the packet moves)}
\end{align}

The radius at any point along the ray is $r(z) = \sqrt{p^2 + z^2}$. The Doppler factor depends only on $z$:
\begin{equation}
1 - \frac{v_z}{c} = 1 - \frac{z}{c\,t_\mathrm{exp}}
\end{equation}

This means the comoving-frame frequency is:
\begin{equation}
\nu_\mathrm{cmf}(z) = \nu_\mathrm{lab}\left(1 - \frac{z}{c\,t_\mathrm{exp}}\right)
\end{equation}
which is linear in $z$ --- exactly as in the Sobolev sweep for real packets.

\begin{definition}[$p$-$z$ Geometry]
For a ray emitted at $(r, \mu_v)$:
\begin{itemize}
\item $p^2 = r^2(1 - \mu_v^2)$ --- the impact parameter squared
\item Shell $s$ boundary at $z = \pm\sqrt{r_s^2 - p^2}$ (inner/outer boundaries)
\item Turning point (closest approach): $z = 0$, $r_\mathrm{min} = p$
\item If $p < R_\mathrm{inner}$ and $\mu_v < 0$: ray hits the photosphere (discarded)
\end{itemize}
\end{definition}

\subsection{Algorithm}\index{Virtual Packets!Algorithm}

\begin{ocrebox}
\textbf{Algorithm: Virtual Packet Tracing}

At each interaction point $(r, \text{shell\_id}, \nu_\mathrm{cmf,emit}, \varepsilon)$:

\textbf{For} $i = 1$ to $N_v$ (default: $N_v = 10$):
\begin{enumerate}
\item \textbf{Draw direction}: $\mu_v \sim U(-1, +1)$
\item \textbf{Compute}: $p^2 = r^2(1 - \mu_v^2)$, $z_0 = r\,\mu_v$
\item \textbf{Lab frequency}: $\nu_\mathrm{lab} = \nu_\mathrm{cmf,emit} / (1 - z_0/(c\,t_\mathrm{exp}))$
\item \textbf{Check}: if $p < R_\mathrm{inner}$ and $\mu_v < 0$ $\to$ skip (hits photosphere)
\item \textbf{Phase 1} (inward, $\mu_v < 0$): trace from $z_0$ toward $z = 0$
  \begin{itemize}
  \item For each shell crossed: accumulate $\tau_\mathrm{line}$ (Sobolev sweep) + $\tau_e = n_e \sigma_T \Delta z$
  \item If turning point reached ($p \geq r_\mathrm{inner,shell}$): reverse to Phase~2
  \end{itemize}
\item \textbf{Phase 2} (outward): trace from turning point to outer boundary
  \begin{itemize}
  \item For each shell crossed: accumulate $\tau_\mathrm{line}$ + $\tau_e$
  \end{itemize}
\item \textbf{Escape}: $P_\mathrm{esc} = e^{-\tau_\mathrm{total}}$ (if $\tau > 50$, skip)
\item \textbf{Bin}: $L_\lambda \mathrel{+}= \varepsilon \cdot L_\mathrm{inner} \cdot P_\mathrm{esc} / (\Delta\lambda \cdot N_v)$
\end{enumerate}
\end{ocrebox}

\subsection{Optical Depth Accumulation}\index{Virtual Packets!Optical Depth}

Within each shell $s$, the virtual packet sweeps from $z_\mathrm{entry}$ to $z_\mathrm{exit}$. The corresponding CMF frequency range is:
\begin{align}
\nu_\mathrm{high} &= \nu_\mathrm{lab}\left(1 - \frac{z_\mathrm{entry}}{c\,t_\mathrm{exp}}\right) \\
\nu_\mathrm{low}  &= \nu_\mathrm{lab}\left(1 - \frac{z_\mathrm{exit}}{c\,t_\mathrm{exp}}\right)
\end{align}

All lines with $\nu_\mathrm{low} \leq \nu_\mathrm{line} \leq \nu_\mathrm{high}$ contribute their Sobolev optical depth:
\begin{equation}
\tau_\mathrm{lines} = \sum_{\nu_\mathrm{low} \leq \nu_j \leq \nu_\mathrm{high}} \tau_{\mathrm{Sob},j}(s)
\end{equation}

The electron scattering contribution is:
\begin{equation}
\tau_e = n_e(s) \, \sigma_T \, |z_\mathrm{exit} - z_\mathrm{entry}|
\end{equation}

The total optical depth is the sum over all shells traversed:
\begin{equation}
\tau_\mathrm{total} = \sum_\mathrm{shells} \left(\tau_\mathrm{lines} + \tau_e\right)
\end{equation}

\subsection{Emission Points}

Virtual packets are emitted at three types of interaction events:
\begin{enumerate}
\item \textbf{Photosphere}: when the real packet is first launched from $R_\mathrm{inner}$
\item \textbf{Line scattering}: after the real packet scatters in a line (resonant, downbranch, or macro-atom)
\item \textbf{Electron scattering}: after a Thomson scatter event
\end{enumerate}

At each event, $N_v = 10$ virtual packets are emitted, sampling $10$ random directions. This means a real packet that undergoes 50 interactions generates $\sim 500$ virtual rays.

\subsection{Strengths and Limitations}

\begin{itemize}
\item[\textbf{+}] Dramatically lower noise than real packets (many more rays sample each spectral bin)
\item[\textbf{+}] No Monte Carlo branching: deterministic ray tracing with cumulative $\tau$
\item[\textbf{+}] Each virtual packet is independent --- ideal for GPU parallelism
\item[\textbf{--}] Computationally expensive: $N_v = 10$ virtual rays per interaction
\item[\textbf{--}] Assumes Sobolev approximation for the formal integral (no partial redistribution)
\item[\textbf{--}] GPU only in LUMINA (requires \texttt{atomicAdd} for spectrum accumulation)
\item[\textbf{--}] Does \emph{not} contribute to $j$ or $\bar\nu$ estimators (transport convergence uses real packets only)
\end{itemize}

\begin{remark}[TARDIS Virtual Packets]
TARDIS uses $N_v \approx 10$--40 virtual packets per interaction. LUMINA defaults to $N_v = 10$, balancing noise reduction against GPU compute cost. The optimal value depends on the number of real packets: for $N_\mathrm{real} \gtrsim 10^6$, real packet noise is already low enough that $N_v = 10$ suffices.
\end{remark}


\section{Rotation Packets}\label{sec:rotation_packets}\index{Spectrum Synthesis!Rotation Packets}\index{Rotation Packets}

The \textbf{rotation packet} method applies Doppler weighting to escaped real packets to compute the spectrum as seen by an observer at a specific viewing angle. This enables modeling of asymmetric or direction-dependent spectral features.

\subsection{Physical Motivation}

In the real-packet method, escaped packets leave the ejecta in random directions. The resulting spectrum is \emph{angle-averaged}: it represents the mean emission over all solid angles. A real observer, however, sees the supernova from a single direction. The Doppler effect means that material moving toward the observer is blueshifted, while receding material is redshifted, producing a direction-dependent spectrum.

In spherical symmetry, the observed spectrum depends on a single parameter: the observer's direction cosine $\mu_\mathrm{obs}$ relative to each escaping packet's velocity vector. The rotation method corrects for this by weighting each escaped packet by a Doppler factor.

\subsection{Doppler Weighting}\index{Rotation Packets!Doppler Weighting}

For a packet escaping at radius $r$ with direction $\mu$ (relative to the radial direction), the velocity at the escape point is $v = r / t_\mathrm{exp}$ and $\beta = v/c$. Two Doppler factors are relevant:

\begin{align}
D_\mathrm{pkt} &= 1 - \beta\,\mu_\mathrm{pkt} & &\text{(packet's actual escape frame)} \label{eq:D_pkt} \\
D_\mathrm{obs} &= 1 - \beta\,\mu_\mathrm{obs} & &\text{(observer's viewing direction)} \label{eq:D_obs}
\end{align}

The specific luminosity transforms between frames as:
\begin{equation}
\boxed{L_{\lambda,\mathrm{obs}} = \left(\frac{D_\mathrm{obs}}{D_\mathrm{pkt}}\right)^2 L_{\lambda,\mathrm{pkt}}}
\label{eq:rotation_weight}
\end{equation}

The quadratic power arises because the spectral flux density transforms as $F_\nu \propto D^2$ under Lorentz boosting (one power for the frequency shift, one for the solid angle transformation).

\subsection{Face-On Observer}

LUMINA defaults to a \textbf{face-on observer} ($\mu_\mathrm{obs} = 1$), looking directly along the radial direction. In this case:
\begin{equation}
D_\mathrm{obs} = 1 - \beta, \quad w = \left(\frac{1 - \beta}{1 - \beta\,\mu_\mathrm{pkt}}\right)^2
\end{equation}

The weighting factor $w$ has the following behavior:
\begin{itemize}
\item $w > 1$: packets that escaped \emph{sideways} ($\mu_\mathrm{pkt} \ll 1$) are \emph{boosted} --- the face-on observer would see them more strongly
\item $w < 1$: packets that escaped nearly radially ($\mu_\mathrm{pkt} \approx 1$) are \emph{suppressed} --- they were already heading toward the observer
\item $w = 1$: when $\mu_\mathrm{pkt} = 1$ (escape direction equals observer direction)
\end{itemize}

In practice, the mean weight $\langle w \rangle \approx 1.0$, confirming energy conservation.

\subsection{Algorithm}

\begin{ocrebox}
\textbf{Algorithm: Rotation Packet Spectrum}
\begin{enumerate}
\item During real-packet transport: for each escaped packet, store $(r, \mu)$ at escape
\item After transport completes, post-process all escaped packets:
  \begin{itemize}
  \item Compute $\beta = r / (c \, t_\mathrm{exp})$
  \item Compute $D_\mathrm{pkt} = 1 - \beta\,\mu_\mathrm{pkt}$ and $D_\mathrm{obs} = 1 - \beta$
  \item Weight: $w = (D_\mathrm{obs} / D_\mathrm{pkt})^2$
  \end{itemize}
\item Bin into spectrum: $L_\lambda \mathrel{+}= \varepsilon \cdot L_\mathrm{inner} \cdot w / \Delta\lambda$
\end{enumerate}
\end{ocrebox}

\subsection{Strengths and Limitations}

\begin{itemize}
\item[\textbf{+}] Essentially free: post-processing with no additional transport
\item[\textbf{+}] Provides observer-direction-dependent spectrum from a single simulation
\item[\textbf{+}] Available on both CPU and GPU
\item[\textbf{+}] Can be computed for arbitrary $\mu_\mathrm{obs}$ without re-running
\item[\textbf{--}] Same Monte Carlo noise as real packets (no extra sampling)
\item[\textbf{--}] In 1D spherical symmetry, the spectrum is isotropic; rotation weighting primarily affects non-radial escape patterns
\item[\textbf{--}] Does not capture true viewing-angle effects from multi-dimensional structure
\end{itemize}


\section{Performance Comparison}\index{Spectrum Synthesis!Performance}

\begin{table}[h]
\centering
\caption{Runtime comparison for 200K packets, 20 iterations (NVIDIA RTX 5000 Ada).}
\label{tab:spectrum_performance}
\begin{tabular}{lrrr}
\toprule
\textbf{Mode} & \textbf{Time per iter} & \textbf{Overhead} & \textbf{Total (20 iter)} \\
\midrule
Real only & 0.73\,s & --- & 14.6\,s \\
Real + Rotation & 0.73\,s & $< 0.01$\,s & 14.7\,s \\
Real + Virtual ($N_v=10$) & 7.3\,s & $+6.6$\,s ($+900\%$) & 146\,s \\
Real + Virtual + Rotation & 7.3\,s & $+6.6$\,s ($+900\%$) & 146\,s \\
\bottomrule
\end{tabular}
\end{table}

\begin{important}
Virtual packets are the dominant performance cost when enabled. The $\sim 10\times$ slowdown comes from tracing $N_v = 10$ virtual rays per interaction, each performing a binary search + sweep through the full line list. For production runs where spectrum quality is paramount, virtual packets are recommended. For parameter fitting where many models must be evaluated quickly, real-only or real+rotation mode is preferred.
\end{important}

\section{When to Use Each Method}\index{Spectrum Synthesis!Recommendations}

\begin{table}[h]
\centering
\caption{Recommended spectrum modes for different use cases.}
\begin{tabular}{lll}
\toprule
\textbf{Use Case} & \textbf{Mode} & \textbf{Rationale} \\
\midrule
Convergence diagnostics & Real only & Fastest; estimators unaffected \\
Parameter search / SBI & Real + Rotation & Fast; observer-frame spectrum \\
Publication spectra & Real + Virtual & Lowest noise; best features \\
Full analysis & All three & Compare all methods \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Command-Line Usage}

\begin{lstlisting}[style=bashstyle,caption={Spectrum mode selection}]
# CPU: real only (default)
./lumina tardis_reference 200000 20

# CPU: real + rotation
./lumina tardis_reference 200000 20 rotation

# GPU: real + virtual (formal integral)
./lumina_cuda atomic/kurucz.h5 200000 output.csv virtual

# GPU: real + rotation
./lumina_cuda atomic/kurucz.h5 200000 output.csv rotation

# GPU: all three methods
./lumina_cuda atomic/kurucz.h5 200000 output.csv all
\end{lstlisting}


%----------------------------------------------------------------------------------------
%	CHAPTER 5: NLTE Rate Equation Solver
%----------------------------------------------------------------------------------------

\chapter{Non-LTE Rate Equation Solver}\index{NLTE}\label{ch:nlte}

\section{Motivation: Beyond the Nebular Approximation}

The nebular approximation (Chapter~8) treats ionization via a modified Saha equation with dilution factor $W$ and radiation temperature $T_\mathrm{rad}$, and level populations via Boltzmann at $T_\mathrm{rad}$.  This is adequate for most photospheric-phase diagnostics but has known limitations:

\begin{itemize}
\item \textbf{UV spectrum}: Boltzmann populations overestimate excited-level populations for Fe-group ions, producing too much UV line blanketing.
\item \textbf{Ionization balance}: The $\zeta$-corrected Saha approximation may not capture the correct Si~II/III ratio in the silicon-burning zone, directly affecting the depth and velocity of the Si~II~6355\,\AA\ feature.
\item \textbf{Calcium H\&K}: The emission-to-absorption ratio of Ca~II depends sensitively on the population of the $4p$ levels, which depart significantly from Boltzmann.
\end{itemize}

LUMINA implements a \textbf{full NLTE solver} for the four most spectroscopically important elements: Si, Ca, Fe, and S (8 ion stages total, $\sim$2000 levels).  For these species, the complete statistical equilibrium is solved including all radiative (bound--bound and bound--free) and collisional rates---the same physics as CMFGEN or PHOENIX.  All other species (C, O, Co, Ni) remain on the nebular approximation, as they contribute negligibly to the optical spectrum of normal SN~Ia at photospheric epochs.

\section{Statistical Equilibrium}\index{NLTE!Statistical Equilibrium}

For each NLTE ion, level populations are determined by the system of statistical equilibrium equations:
\begin{equation}
\boxed{\sum_{j \neq i} n_j \, R_{j \to i} = n_i \sum_{j \neq i} R_{i \to j} \quad \text{for each level } i}
\label{eq:stat_equil}
\end{equation}
where $R_{i \to j}$ is the total (radiative + collisional) rate from level $i$ to level $j$.  This forms a linear system $\mathbf{A} \mathbf{n} = \mathbf{0}$, supplemented by the conservation equation:
\begin{equation}
\sum_i n_i = n_\mathrm{total} \quad (\text{from nebular ionization balance})
\label{eq:nlte_conservation}
\end{equation}

\subsection{Rate Matrix Structure}

The rate matrix $\mathbf{A}$ has dimensions $N \times N$ where $N$ is the combined level count for an ion pair (e.g., Si~II + Si~III).  Ion pairs are solved together because photoionization and recombination couple the two stages.

\begin{table}[h]
\centering
\caption{NLTE ion pairs and matrix dimensions.}
\label{tab:nlte_ions}
\begin{tabular}{lrrr}
\toprule
\textbf{Ion pair} & \textbf{Levels} & \textbf{Matrix size} & \textbf{NLTE lines} \\
\midrule
Si~II + Si~III & $100 + 169 = 269$ & $269 \times 269$ & $\sim$2,400 \\
Ca~II + Ca~III & $93 + 150 = 243$ & $243 \times 243$ & $\sim$1,700 \\
Fe~II + Fe~III & $796 + 566 = 1{,}362$ & $1362 \times 1362$ & $\sim$28,000 \\
S~II + S~III   & $85 + 58 = 143$  & $143 \times 143$  & $\sim$4,500 \\
\midrule
\textbf{Total} & \textbf{2,017} & --- & $\sim$36,600 \\
\bottomrule
\end{tabular}
\end{table}

The matrix element $A_{ij}$ ($i \neq j$) represents the rate of transitions \emph{into} level $i$ from level $j$.  The diagonal $A_{ii} = -\sum_{j \neq i} R_{i \to j}$ ensures row sums are zero.

\section{Transition Rates}\index{NLTE!Transition Rates}

\subsection{Radiative Bound--Bound}

Using Einstein coefficients loaded from the atomic database:
\begin{align}
R_\mathrm{abs}(l \to u) &= B_{lu} \, \bar{J}(\nu_{lu}) & \text{(absorption)} \\
R_\mathrm{stim}(u \to l) &= B_{ul} \, \bar{J}(\nu_{lu}) & \text{(stimulated emission)} \\
R_\mathrm{spont}(u \to l) &= A_{ul} & \text{(spontaneous emission)}
\end{align}
where $\bar{J}(\nu)$ is the angle-averaged mean intensity at the line frequency, obtained from the Monte Carlo frequency histogram (Section~\ref{sec:jnu_histogram}).

\subsection{Collisional Bound--Bound}

Since no collision data exists for Si/Ca/Fe/S in the atomic database, we use standard approximation formulas:

\paragraph{Permitted transitions} (van Regemorter 1962):
\begin{equation}
C_{l \to u} = 2.16 \times 10^{-6} \, n_e \, f_{lu} \, \frac{\bar{g} \, e^{-\Delta E / k_B T_e}}{g_l \, \sqrt{T_e}}
\label{eq:van_regemorter}
\end{equation}
with effective Gaunt factor $\bar{g} \approx 0.2$ for allowed transitions.

\paragraph{Forbidden transitions} (Axelrod 1980):
\begin{equation}
C_{l \to u} = 8.63 \times 10^{-6} \, n_e \, \frac{\Omega}{g_l \, \sqrt{T_e}} \, e^{-\Delta E / k_B T_e}
\label{eq:axelrod}
\end{equation}
with effective collision strength $\Omega \approx 1.0$.

\paragraph{Downward collisional rates} follow detailed balance:
\begin{equation}
C_{u \to l} = C_{l \to u} \, \frac{g_l}{g_u} \, e^{\Delta E / k_B T_e}
\end{equation}

\subsection{Photoionization}\index{NLTE!Photoionization}

Photoionization couples the lower ion to the ground state of the higher ion via the Kramers hydrogenic cross-section:
\begin{equation}
\sigma_\mathrm{bf}(\nu) = \sigma_0 \left(\frac{\nu_\mathrm{thresh}}{\nu}\right)^3 \quad \text{for } \nu \geq \nu_\mathrm{thresh}
\label{eq:kramers}
\end{equation}
where $\sigma_0 = 7.91 \times 10^{-18} / Z_\mathrm{eff}^2$\,cm$^2$ and $\nu_\mathrm{thresh} = (\chi - E_l) / h$ is the level-dependent ionization threshold.  The photoionization rate is:
\begin{equation}
R_\mathrm{bf}(l) = \int_{\nu_\mathrm{thresh}}^{\infty} \frac{4\pi \, \bar{J}_\nu \, \sigma_\mathrm{bf}(\nu)}{h\nu} \, d\nu
\end{equation}
evaluated numerically over the $\bar{J}_\nu$ histogram.

\subsection{Recombination}

Recombination rates follow from the Milne detailed-balance relation:
\begin{equation}
R_\mathrm{rec}(l) = R_\mathrm{bf}(l) \times n_e \left(\frac{h^2}{2\pi m_e k_B T_e}\right)^{3/2} \frac{g_l}{2\,g_\mathrm{ion}} \, e^{(\chi - E_l) / k_B T_e}
\end{equation}

\section{The $\bar{J}_\nu$ Frequency Histogram}\label{sec:jnu_histogram}\index{NLTE!J nu Histogram}

To evaluate radiative rates, the solver needs the frequency-resolved mean intensity $\bar{J}_\nu$ in each shell.  This is accumulated during Monte Carlo transport as a logarithmically-binned frequency histogram:

\begin{equation}
j_\nu^\mathrm{raw}(s, b) = \sum_\mathrm{steps} \epsilon_\mathrm{cmf} \times d_\mathrm{step} \quad \text{for } \nu_\mathrm{cmf} \in \text{bin } b
\end{equation}

normalized after each iteration to physical units:
\begin{equation}
\bar{J}_\nu(s, b) = \frac{j_\nu^\mathrm{raw}(s, b)}{4\pi \, V_\mathrm{shell} \, \Delta t_\mathrm{sim} \, \Delta\nu_b}
\end{equation}

\begin{definition}[Frequency Grid]
1000 logarithmically spaced bins covering $\nu_\mathrm{min} = 1.5 \times 10^{14}$\,Hz ($\lambda = 20{,}000$\,\AA) to $\nu_\mathrm{max} = 3 \times 10^{16}$\,Hz ($\lambda = 100$\,\AA), with $\Delta\log\nu = 0.00529$ per bin ($\sim$1.2\% resolution).
\end{definition}

On the GPU, each packet step adds one \texttt{atomicAdd} to the appropriate frequency bin, using the comoving-frame frequency already computed for the standard $j$-estimator.  The memory cost is 240\,KB (30 shells $\times$ 1000 bins $\times$ 8 bytes).

\section{Matrix Solve: CPU and GPU Paths}\index{NLTE!Matrix Solver}

\subsection{CPU Path: Column-Oriented Gaussian Elimination}

For the CPU binary (\texttt{lumina}), the rate matrix is solved via Gaussian elimination with partial pivoting.  The matrix is stored in column-major format (for compatibility with the GPU path), and the elimination uses a cache-friendly column-oriented algorithm where the inner loop iterates over rows within a column (stride-1 access):

\begin{lstlisting}[language=C,caption={Cache-friendly column-oriented elimination},label=lst:gauss_cm]
// Inner loop: column j (outer), row i (inner = contiguous)
for (int j = k + 1; j < N; j++) {
    double A_kj = A[j * N + k];  // pivot row element
    for (int i = k + 1; i < N; i++)
        A[j * N + i] -= A[k * N + i] * A_kj;
}
\end{lstlisting}

With OpenMP parallelization across shells (\texttt{schedule(dynamic,1)}), the CPU NLTE solve takes $\sim$20\,s for all 4 ion pairs $\times$ 30 shells (dominated by Fe at $1362 \times 1362$).

\subsection{GPU Path: cuBLAS Batched LU Factorization}

For the GPU binary (\texttt{lumina\_cuda}), the matrix solve uses cuBLAS batched operations to solve all 30 shells simultaneously on the GPU:

\begin{enumerate}
\item \textbf{Assembly (CPU, OpenMP)}: For each ion pair, assemble $N \times N$ rate matrices for all 30 shells in parallel ($\sim$100\,ms).
\item \textbf{Upload}: Copy matrices and RHS vectors to GPU.
\item \textbf{LU factorization}: \texttt{cublasDgetrfBatched()} --- batched LU decomposition of 30 matrices.
\item \textbf{Triangular solve}: \texttt{cublasDgetrsBatched()} --- batched forward/back substitution.
\item \textbf{Download}: Copy solution vectors back to CPU.
\end{enumerate}

\begin{table}[h]
\centering
\caption{NLTE solver performance comparison (200K packets, 3 iterations).}
\label{tab:nlte_performance}
\begin{tabular}{lrrr}
\toprule
\textbf{Configuration} & \textbf{Total time} & \textbf{NLTE overhead} & \textbf{Speedup} \\
\midrule
GPU transport, no NLTE        & 6.1\,s  & ---    & --- \\
GPU transport + cuBLAS NLTE   & 9.1\,s  & 3.0\,s & 1.0$\times$ \\
CPU+OMP transport + Gauss NLTE & 22.8\,s & 15.4\,s & --- \\
\bottomrule
\end{tabular}
\end{table}

The cuBLAS batched solve reduces the NLTE matrix solve from $\sim$20\,s (CPU Gaussian elimination) to $\sim$3\,s, a \textbf{7$\times$ speedup}.  At production packet counts (2M+), the NLTE overhead becomes negligible compared to the transport kernel.

\begin{important}
GPU memory for the cuBLAS solver: the Fe $1362 \times 1362$ matrices for 30 shells require $30 \times 1362^2 \times 8 = 425$\,MB of GPU memory, pre-allocated at initialization.  This fits comfortably within the 32\,GB VRAM of the RTX~5000~Ada.
\end{important}

\section{$\tau_\mathrm{Sobolev}$ Update from NLTE Populations}\index{NLTE!Tau Sobolev Update}

After solving the rate equations, the Sobolev optical depth for each NLTE line is recomputed using the NLTE level populations instead of Boltzmann:
\begin{equation}
\tau_\mathrm{Sob} = \frac{\pi e^2}{m_e c} \, f_{lu} \, \lambda_\mathrm{cm} \, t_\mathrm{exp} \, n_l \left(1 - \frac{g_l \, n_u}{g_u \, n_l}\right)
\end{equation}
where $n_l$ and $n_u$ are the NLTE lower and upper level populations respectively.  Lines not belonging to NLTE ions retain their nebular $\tau$ values.

\section{Integration into the Iteration Loop}\index{NLTE!Iteration Loop}

The NLTE solver is called after each Monte Carlo iteration (for iterations $> 1$), following the standard plasma state update:

\begin{ocrebox}
\textbf{Iteration workflow with NLTE enabled}
\begin{enumerate}
\item Monte Carlo transport kernel $\longrightarrow$ $j_\nu$ histogram + standard estimators
\item Solve radiation field: update $W$, $T_\mathrm{rad}$, $T_\mathrm{inner}$
\item Nebular plasma state: partition functions, $n_e$, Saha ionization, $\tau_\mathrm{Sob}$
\item \textbf{NLTE solve}: normalize $\bar{J}_\nu$ $\to$ assemble rate matrices $\to$ solve (GPU/CPU) $\to$ update $\tau$ for NLTE lines
\item Re-upload $\tau_\mathrm{Sob}$ to GPU for next iteration
\end{enumerate}
\end{ocrebox}

Enable NLTE via the command line or environment variable:
\begin{lstlisting}[language=bash]
# GPU
./lumina_cuda data/tardis_reference 200000 20 real nlte

# CPU
./lumina data/tardis_reference 200000 20 real nlte

# Or via environment variable
LUMINA_NLTE=1 ./lumina_cuda data/tardis_reference 200000 20
\end{lstlisting}


\section{Roadmap: All-Species NLTE}\index{NLTE!Roadmap}

While the current NLTE solver covers the four most important optical diagnostic elements, a complete treatment requires additional species and inter-species coupling.

\subsection{Species Coverage}

Table~\ref{tab:nlte_tiers} shows the prioritised expansion roadmap.

\begin{table}[h]
\centering
\caption{NLTE species expansion tiers for SN~Ia.}
\label{tab:nlte_tiers}
\small
\begin{tabular}{clrrp{5.5cm}}
\toprule
\textbf{Tier} & \textbf{Ion pair} & \textbf{Levels} & \textbf{Lines} & \textbf{Motivation} \\
\midrule
\multirow{4}{*}{Current}
  & Si II/III & 269 & 1,815 & Si~II~6355\,\AA\ (primary SN~Ia diagnostic) \\
  & Ca II/III & 243 & 2,518 & Ca~II H\&K, NIR triplet \\
  & Fe II/III & 1,362 & 31,613 & UV/optical line blanketing (dominant) \\
  & S  II/III & 143 & 670 & S~``W'' feature at 5640\,\AA \\
\midrule
\multirow{2}{*}{1}
  & Co II/III & 469 & 5,100 & $^{56}$Ni decay product; optical blanketing \\
  & Ni II/III & 1,061 & 22,606 & $^{56}$Ni parent; Fe-group blanketing \\
\midrule
\multirow{2}{*}{2}
  & C  II    & $\sim$40 & $\sim$200 & C~II~6580\,\AA\ (unburned carbon diagnostic) \\
  & Mg II    & $\sim$50 & $\sim$100 & Mg~II~4481\,\AA\ (high-$v$ SN~Ia) \\
\bottomrule
\end{tabular}
\end{table}

\noindent After Tier~1, the NLTE solver will cover $\sim$3500 levels across 6 ion pairs, accounting for $>$99\% of the optical depth in normal SN~Ia.  The runtime overhead is modest: cuBLAS batched LU scales well, and the added Ni~II/III ($1061 \times 1061$ matrix) is smaller than the existing Fe~II/III ($1362 \times 1362$).

\begin{table}[h]
\centering
\caption{Estimated runtime impact of NLTE expansion.}
\label{tab:nlte_runtime}
\begin{tabular}{lrrl}
\toprule
\textbf{Component} & \textbf{Current (4 pairs)} & \textbf{After Tier 1 (6 pairs)} & \textbf{Change} \\
\midrule
Rate matrix construction & $\sim$1.5\,s & $\sim$2.7\,s & +80\% \\
cuBLAS LU solve & $\sim$1.5\,s & $\sim$2.0\,s & +33\% \\
\textbf{NLTE subtotal} & \textbf{$\sim$3.0\,s} & \textbf{$\sim$4.7\,s} & +57\% \\
MC Transport & $\sim$10\,s & $\sim$10\,s & 0\% \\
\textbf{Total per model} & \textbf{$\sim$14\,s} & \textbf{$\sim$15.7\,s} & +12\% \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Charge Exchange}\index{NLTE!Charge Exchange}

A physically important process omitted from most Monte Carlo NLTE implementations is \textbf{charge exchange} (CE):
\begin{equation}
\mathrm{A}^{+} + \mathrm{B}^{2+} \rightleftharpoons \mathrm{A}^{2+} + \mathrm{B}^{+}
\end{equation}
Unlike photoionisation (which depends on $J_\nu$) or collisional ionisation (which depends on $n_e$), CE rates depend on the \emph{product of two ion densities}:
\begin{equation}
R_\mathrm{CE} = n(\mathrm{A}^{+}) \cdot n(\mathrm{B}^{2+}) \cdot \langle \sigma v \rangle_\mathrm{CE}
\end{equation}
with typical $\langle \sigma v \rangle_\mathrm{CE} \sim 10^{-9}$\,cm$^3$/s \citep{kingdon1996}.  In the dense inner shells of SN~Ia ejecta ($n_\mathrm{ion} \sim 10^{8}$--$10^{9}$\,cm$^{-3}$), CE rates can rival or exceed radiative recombination rates.

\begin{important}
The most important CE reactions for SN~Ia are:
\begin{itemize}
\item Fe$^+$ + Co$^{2+}$ $\rightleftharpoons$ Fe$^{2+}$ + Co$^+$ \ (Fe/Co co-located in $^{56}$Ni decay zone)
\item Fe$^+$ + Ni$^{2+}$ $\rightleftharpoons$ Fe$^{2+}$ + Ni$^+$ \ ($^{56}$Ni parent material)
\item Si$^+$ + Ca$^{2+}$ $\rightleftharpoons$ Si$^{2+}$ + Ca$^+$ \ (near-resonant ionisation potentials)
\end{itemize}
\end{important}

\subsection{Implementation Strategy}

LUMINA currently solves each ion pair independently.  Adding CE coupling does \emph{not} require solving all species simultaneously---even CMFGEN uses iterative convergence rather than a monolithic matrix:

\begin{ocrebox}
\textbf{Iterative CE coupling scheme}
\begin{enumerate}
\item Solve each ion pair's NLTE rate equations independently (current approach).
\item After all pairs are solved, compute CE rates using the updated ionisation fractions.
\item Add CE rates as additional source/sink terms to each ion pair's rate matrix.
\item Re-solve all ion pairs with the updated rates.
\item Repeat steps 2--4 until ionisation fractions converge (typically 3--5 inner iterations).
\end{enumerate}
\end{ocrebox}

\noindent This approach couples the species through $n_e$, $T$, and the CE rates themselves, without increasing the matrix dimensions.  The additional cost is $\sim$3--5 re-solves of the existing batched LU system, adding at most $\sim$10\,s per Monte Carlo iteration.


%========================================================================================
%	PART II: CODE ARCHITECTURE
%========================================================================================

\part{Code Architecture}

%----------------------------------------------------------------------------------------
%	CHAPTER 5: Overview & Build System
%----------------------------------------------------------------------------------------

\chapter{Overview \& Build System}\index{Build System}

\section{File Structure}

LUMINA-SN consists of the following source files:

\begin{table}[h]
\centering
\caption{Source files and their roles.}
\begin{tabular}{lrl}
\toprule
\textbf{File} & \textbf{Lines} & \textbf{Purpose} \\
\midrule
\texttt{lumina.h} & 378 & Master header: all structures, constants, prototypes \\
\texttt{lumina\_transport.c} & 515 & CPU transport kernel (real + rotation) \\
\texttt{lumina\_plasma.c} & 524 & Plasma solver \& convergence \\
\texttt{lumina\_atomic.c} & 700 & Atomic data loading (HDF5, CSV, NPY) \\
\texttt{lumina\_main.c} & 466 & Main driver \& iteration loop \\
\texttt{lumina\_cuda.cu} & 1353 & CUDA GPU kernel (real + virtual + rotation) \\
\midrule
\textbf{Total} & \textbf{3936} & \\
\bottomrule
\end{tabular}
\end{table}

\section{Build System}\index{Build System!Makefile}

\begin{lstlisting}[style=bashstyle,caption={Building LUMINA-SN}]
# CPU build (serial)
make

# CPU build with OpenMP parallelism
make OMP=1

# CUDA GPU build
make cuda
\end{lstlisting}

\begin{table}[h]
\centering
\caption{Compiler flags.}
\begin{tabular}{lll}
\toprule
\textbf{Target} & \textbf{Compiler} & \textbf{Flags} \\
\midrule
CPU & \texttt{gcc} & \texttt{-O2 -Wall -Wextra -std=c11 -lm} \\
CPU+OMP & \texttt{gcc} & adds \texttt{-fopenmp} \\
GPU & \texttt{nvcc} & \texttt{-O2 -arch=sm\_89 -std=c++14} \\
\bottomrule
\end{tabular}
\end{table}

\begin{important}
\texttt{make clean} deletes CSV output files. Always save important spectral outputs before rebuilding.
\end{important}

\section{Dependencies}

\begin{itemize}
\item \textbf{HDF5} (optional): For loading atomic data from \texttt{kurucz\_cd23\_chianti\_H\_He.h5}
\item \textbf{CUDA Toolkit $\geq$ 12.0}: For GPU builds (tested with CUDA 13.0, sm\_89)
\item \textbf{OpenMP}: For CPU parallelism (optional)
\item \textbf{Standard C library}: \texttt{math.h}, \texttt{stdio.h}, \texttt{stdlib.h}, \texttt{string.h}
\end{itemize}

\section{Execution}\index{Execution}

\begin{lstlisting}[style=bashstyle,caption={Running LUMINA-SN}]
# CPU: reference model with 200K packets, 20 iterations
./lumina tardis_reference 200000 20

# CUDA: same with GPU acceleration
./lumina_cuda atomic/kurucz_cd23_chianti_H_He.h5 200000 output.csv
\end{lstlisting}


%----------------------------------------------------------------------------------------
%	CHAPTER 6: Data Structures
%----------------------------------------------------------------------------------------

\chapter{Data Structures}\index{Data Structures}

\section{The \texttt{RPacket} Structure}\index{Data Structures!RPacket}

The fundamental unit of the Monte Carlo simulation:

\begin{lstlisting}[style=cstyle,caption={\texttt{RPacket} --- photon energy packet}]
typedef struct {
    double r;                // radial position [cm]
    double mu;               // cos(theta) direction
    double nu;               // lab-frame frequency [Hz]
    double energy;           // packet energy [erg]
    int    current_shell_id; // shell index [0..n_shells-1]
    int    next_line_id;     // Sobolev sweep bookmark
    PacketStatus status;     // IN_PROCESS / EMITTED / REABSORBED
    int    index;            // packet ID (for RNG seeding)
} RPacket;
\end{lstlisting}

\section{Geometry}\index{Data Structures!Geometry}

The 1D spherically symmetric ejecta model:

\begin{lstlisting}[style=cstyle,caption={\texttt{Geometry} --- shell structure}]
typedef struct {
    int    n_shells;         // number of shells (default: 30)
    double *r_inner;         // [n_shells] inner radii [cm]
    double *r_outer;         // [n_shells] outer radii [cm]
    double *v_inner;         // [n_shells] inner velocities [cm/s]
    double *v_outer;         // [n_shells] outer velocities [cm/s]
    double time_explosion;   // t_exp [seconds]
} Geometry;
\end{lstlisting}

The radii are derived from velocities via homologous expansion: $r = v \times t_\mathrm{exp}$.

\section{Opacity State}\index{Data Structures!OpacityState}

Pre-computed opacity data used during transport:

\begin{lstlisting}[style=cstyle,caption={\texttt{OpacityState} --- line and continuum opacities}]
typedef struct {
    int n_lines, n_shells;
    double *line_list_nu;         // [n_lines] rest frequencies, descending
    double *tau_sobolev;          // [n_lines * n_shells]
    double *electron_density;     // [n_shells] n_e [cm^-3]
    double *t_electrons;          // [n_shells] T_e [K]

    // Macro-atom transition data
    int n_macro_levels, n_macro_transitions;
    int    *macro_block_references;       // [n_levels+1]
    int    *transition_type;              // [n_transitions]
    int    *destination_level_id;         // [n_transitions]
    int    *transition_line_id;           // [n_transitions]
    double *transition_probabilities;     // [n_transitions * n_shells]
    int    *line2macro_level_upper;       // [n_lines]
} OpacityState;
\end{lstlisting}

\begin{remark}[Line List Ordering]
Lines are sorted in \emph{descending} frequency order. As a packet's CMF frequency decreases while traversing a shell, it encounters lines from high to low frequency. This ordering enables efficient forward-only scanning.
\end{remark}

\section{Plasma State}\index{Data Structures!PlasmaState}

Thermodynamic state updated each iteration:

\begin{lstlisting}[style=cstyle,caption={\texttt{PlasmaState} --- radiation field quantities}]
typedef struct {
    int    n_shells;
    double *W;               // [n_shells] dilution factor
    double *T_rad;           // [n_shells] radiation temperature [K]
    double *rho;             // [n_shells] mass density [g/cm^3]
    double *n_electron;      // [n_shells] electron density [cm^-3]
    double T_e_T_rad_ratio;  // default: 0.9
} PlasmaState;
\end{lstlisting}

\section{Atomic Data}\index{Data Structures!AtomicData}

Comprehensive atomic physics database for the plasma solver:

\begin{lstlisting}[style=cstyle,caption={\texttt{AtomicData} --- atomic physics for Saha--Boltzmann}]
typedef struct {
    // Per-line data
    int    *line_atomic_number;    // [n_lines] Z
    int    *line_ion_number;       // [n_lines] ionization stage
    double *line_f_lu;             // [n_lines] oscillator strength
    double *line_wavelength_cm;    // [n_lines] rest wavelength

    // Energy levels
    int     n_levels;
    double *level_energy_eV;       // [n_levels]
    int    *level_g;               // [n_levels] statistical weight
    int    *level_metastable;      // [n_levels] 0 or 1

    // Ionization energies
    int     n_ionization;
    double *ioniz_energy_eV;       // [n_ionization]

    // Zeta correction factors (dilute non-LTE)
    double *zeta_data;             // [n_zeta_ions * n_zeta_temps]

    // Abundances
    double *abundances;            // [n_elements * n_shells]

    // Computed quantities (updated each iteration)
    double *ion_number_density;    // [n_ion_pops * n_shells]
    double *partition_functions;   // [n_ion_pops * n_shells]
} AtomicData;
\end{lstlisting}

\section{Monte Carlo Estimators}\index{Data Structures!Estimators}

Accumulated during transport, used to update the radiation field:

\begin{lstlisting}[style=cstyle,caption={\texttt{Estimators} --- radiation field accumulators}]
typedef struct {
    double *j_estimator;         // [n_shells] integral of E*ds
    double *nu_bar_estimator;    // [n_shells] integral of E*nu*ds
    double *j_blue_estimator;    // [n_lines * n_shells] (CPU only)
    double *Edotlu_estimator;    // [n_lines * n_shells] (CPU only)
} Estimators;
\end{lstlisting}

\begin{remark}[GPU Limitation]
The \texttt{j\_blue} and \texttt{Edotlu} estimators are \emph{not computed} on the GPU because they require $n_\mathrm{lines} \times n_\mathrm{shells} \approx 4$~million atomic additions per iteration --- prohibitively expensive for \texttt{atomicAdd}.
\end{remark}


%----------------------------------------------------------------------------------------
%	CHAPTER 7: Transport Engine
%----------------------------------------------------------------------------------------

\chapter{Transport Engine}\index{Transport Engine}

\section{Overview}

The transport engine (\texttt{lumina\_transport.c}, 515 lines) propagates $r$-packets through the ejecta. It is the most performance-critical component.

\section{The \texttt{trace\_packet} Function}\index{Transport Engine!trace\_packet}

This function computes the next interaction event for a packet:

\begin{enumerate}
\item Compute distance to shell boundaries ($d_\mathrm{boundary}$)
\item Scan the Sobolev line list for resonances ($d_\mathrm{line}$, accumulated $\tau$)
\item Compute distance to electron scattering ($d_e = \tau_\mathrm{event} / (n_e \sigma_T)$)
\item Return the minimum distance and interaction type
\end{enumerate}

\section{Sobolev Line Sweep}\index{Transport Engine!Sobolev Sweep}

The sweep algorithm processes lines in descending frequency order:

\begin{lstlisting}[style=cstyle,caption={Sobolev sweep (simplified)}]
double tau_trace_combined = 0.0;
for (int j = pkt->next_line_id; j < n_lines; j++) {
    double nu_line = line_list_nu[j];
    double d_line = compute_d_line(pkt, nu_line);

    if (d_line < 0 || d_line > d_boundary) break;

    double tau_line = tau_sobolev[j * n_shells + shell_id];
    tau_trace_combined += tau_line;

    if (tau_trace_combined > tau_event) {
        // Line interaction!
        *interaction_type = INTERACTION_LINE;
        *d_min = d_line;
        pkt->next_line_id = j;
        return;
    }
}
\end{lstlisting}

\section{Thomson Scattering}\index{Transport Engine!Thomson Scattering}

Elastic scattering with free electrons:

\begin{enumerate}
\item Transform packet energy/frequency to comoving frame at current angle
\item Sample new direction: $\mu_\mathrm{new} \sim U(-1, +1)$ (isotropic in CMF)
\item Transform back to lab frame with new angle
\item Energy is conserved in the comoving frame
\end{enumerate}

\begin{equation}
\varepsilon_\mathrm{lab,new} = \varepsilon_\mathrm{cmf} \times \frac{1}{1 - \mu_\mathrm{new} \cdot v/c}
\end{equation}

\section{Boundary Crossing}\index{Transport Engine!Boundary Crossing}

When a packet crosses a shell boundary:
\begin{enumerate}
\item Update shell index: $i_\mathrm{shell} \leftarrow i_\mathrm{shell} + \delta$ where $\delta = +1$ (outward) or $-1$ (inward)
\item Nudge position by $\epsilon = 10^{-10} \times \Delta r_\mathrm{shell}$ into the new shell
\item Check for escape ($i > n_\mathrm{shells} - 1$) or reabsorption ($i < 0$, inward-moving)
\end{enumerate}

\begin{important}
The position nudge is critical. Without it, the packet lands exactly on the boundary, and the next distance calculation returns $d = 0$, causing an infinite loop (Task \#024).
\end{important}


%----------------------------------------------------------------------------------------
%	CHAPTER 8: Plasma Physics Solver
%----------------------------------------------------------------------------------------

\chapter{Plasma Physics Solver}\index{Plasma Solver}

\section{Overview}

The plasma solver (\texttt{lumina\_plasma.c}, 524 lines) computes the thermodynamic state of the ejecta for each iteration. It implements the TARDIS-compatible nebular approximation \citep{mazzali1993}.

\section{Step 1: Partition Functions}\index{Plasma Solver!Partition Functions}

The partition function for ion $(Z, \text{stage})$ in shell $s$ is:
\begin{equation}
\mathcal{Z}(Z, \text{stage}, s) = \underbrace{\sum_{i \in \text{meta}} g_i \, e^{-E_i / k_B T_\mathrm{rad}(s)}}_{\mathcal{Z}_\mathrm{meta}} + W(s) \cdot \underbrace{\sum_{i \in \text{non-meta}} g_i \, e^{-E_i / k_B T_\mathrm{rad}(s)}}_{\mathcal{Z}_\mathrm{non}}
\label{eq:partition}
\end{equation}

\begin{important}
The Boltzmann factors use $T_\mathrm{rad}$ for \emph{all} levels (both metastable and non-metastable). Earlier code incorrectly used $T_e$ for metastable levels. The dilution factor $W$ suppresses the non-metastable contribution at large distances from the photosphere.
\end{important}

\section{Step 2: Electron Density}\index{Plasma Solver!Electron Density}

Computed iteratively with TARDIS-style damping:

\begin{ocrebox}
\textbf{Algorithm: Electron Density Iteration}
\begin{enumerate}
\item Start with initial guess $n_e^{(0)}$
\item For each element: compute ionization ratios using nebular Saha (Eq.~\ref{eq:saha_neb})
\item Normalize ion populations to element abundance
\item Compute $n_e^{(\text{calc})} = \sum_\text{ions} \text{stage} \times n_\text{ion}$
\item Damped update: $n_e^{(k+1)} = 0.5 \times n_e^{(\text{calc})} + 0.5 \times n_e^{(k)}$
\item Convergence: $|n_e^{(k+1)} - n_e^{(k)}| / n_e^{(k)} < 0.05$
\end{enumerate}
\end{ocrebox}

\section{Step 3: Nebular Saha Ionization}\index{Plasma Solver!Saha Equation}

The ionization ratio between consecutive stages is:
\begin{equation}
\boxed{\frac{n_{i+1}}{n_i} = \frac{\Phi_\mathrm{neb}}{n_e}}
\label{eq:saha_neb}
\end{equation}

where the nebular ionization coefficient $\Phi_\mathrm{neb}$ is:
\begin{equation}
\Phi_\mathrm{neb} = \Phi_\mathrm{LTE} \times W \times \left[\zeta \cdot \delta + W \cdot (1 - \zeta)\right] \times \sqrt{\frac{T_e}{T_\mathrm{rad}}}
\end{equation}

\begin{align}
\Phi_\mathrm{LTE} &= \frac{\mathcal{Z}_{i+1}}{\mathcal{Z}_i} \times 2 \times g_e \times e^{-\chi / k_B T_\mathrm{rad}} \\[4pt]
g_e &= \left(\frac{2\pi m_e k_B T_\mathrm{rad}}{h^2}\right)^{3/2} \\[4pt]
\delta &= \frac{T_e}{T_\mathrm{rad}} \exp\left[\chi \left(\frac{1}{k_B T_\mathrm{rad}} - \frac{1}{k_B T_e}\right)\right]
\end{align}

Here $\chi$ is the ionization energy, and $\zeta$ is a non-LTE correction factor interpolated from tabulated values.

\section{Step 4: $\tau_\mathrm{Sobolev}$ Update}\index{Plasma Solver!Tau Sobolev}

With ion populations known, $\tau_\mathrm{Sob}$ is recomputed for each line and shell using Eq.~\eqref{eq:tau_sobolev}. The level populations follow the Boltzmann distribution within each ion:

\begin{equation}
n_{l,\text{meta}} = \frac{g_l}{\mathcal{Z}} \, n_\text{ion} \, e^{-E_l / k_B T_\mathrm{rad}}, \quad
n_{l,\text{non}} = W \times \frac{g_l}{\mathcal{Z}} \, n_\text{ion} \, e^{-E_l / k_B T_\mathrm{rad}}
\end{equation}

\section{Step 5: Radiation Field Update}\index{Plasma Solver!Radiation Field}

From the MC estimators $j$ and $\overline{\nu}$ (Eqs.~\ref{eq:j_est}--\ref{eq:nubar_est}):
\begin{align}
T_\mathrm{rad,est}(s) &= 1.2523 \times 10^{-11} \times \frac{\overline{\nu}(s)}{j(s)} \quad \text{[K]} \\
W_\mathrm{est}(s) &= \frac{j(s)}{4\,\sigma_\mathrm{SB}\,T_\mathrm{rad}^4(s)\,\Delta t\,V(s)}
\end{align}

All quantities are damped:
\begin{equation}
X_\mathrm{new} = X_\mathrm{old} + 0.5 \times (X_\mathrm{est} - X_\mathrm{old})
\end{equation}


%----------------------------------------------------------------------------------------
%	CHAPTER 9: Atomic Data System
%----------------------------------------------------------------------------------------

\chapter{Atomic Data System}\index{Atomic Data}

\section{Data Sources}

LUMINA uses the TARDIS reference atomic dataset, originally from Kurucz CD23 and CHIANTI:

\begin{table}[h]
\centering
\caption{Atomic data files.}
\label{tab:atomic_files}
\begin{tabular}{lll}
\toprule
\textbf{File} & \textbf{Format} & \textbf{Contents} \\
\midrule
\texttt{line\_list.csv} & CSV & $\nu$, $Z$, ion, $f_{lu}$, $\lambda$ per line \\
\texttt{levels.csv} & CSV & $E$ (eV), $g$, metastable flag per level \\
\texttt{ionization\_energies.csv} & CSV & $\chi$ per ion \\
\texttt{tau\_sobolev.npy} & NPY & $\tau_\mathrm{Sob}$ reference values \\
\texttt{transition\_probabilities.npy} & NPY & Macro-atom transition probs \\
\texttt{macro\_atom\_data.csv} & CSV & Transition types, destinations \\
\texttt{zeta\_data.npy} & NPY & Non-LTE correction factors \\
\texttt{abundances.csv} & CSV & Mass fractions per shell \\
\bottomrule
\end{tabular}
\end{table}

\section{The NPY Format Reader}\index{Atomic Data!NPY Format}

LUMINA includes a custom NPY reader (no NumPy dependency in C):

\begin{enumerate}
\item Read 6-byte magic: \texttt{\textbackslash x93NUMPY}
\item Read version (1 or 2) and header length
\item Parse Python dict header for \texttt{shape}, \texttt{dtype}, \texttt{fortran\_order}
\item Read raw binary data
\item Transpose if Fortran-ordered
\end{enumerate}

\section{The CSV Parser}\index{Atomic Data!CSV Parser}

\begin{important}
The \texttt{macro\_atom\_data.csv} header starts with an unnamed index column: ``\texttt{,atomic\_number,...}''. The standard \texttt{strtok()} function skips leading delimiters, causing a column offset of $-1$. LUMINA uses a manual field-by-field parser that handles empty fields correctly.
\end{important}


%----------------------------------------------------------------------------------------
%	CHAPTER 10: CUDA GPU Implementation
%----------------------------------------------------------------------------------------

\chapter{CUDA GPU Implementation}\index{CUDA}

\section{Design Philosophy}

The GPU implementation maps \textbf{one CUDA thread per packet}. Each thread independently propagates its packet through the ejecta, requiring no inter-thread communication except for atomic estimator updates.

\section{Memory Layout}\index{CUDA!Memory Layout}

\begin{table}[h]
\centering
\caption{GPU memory allocation.}
\begin{tabular}{llr}
\toprule
\textbf{Data} & \textbf{Access} & \textbf{Size (200K pkts)} \\
\midrule
Line frequencies & Read-only & $n_\mathrm{lines} \times 8$~B \\
$\tau_\mathrm{Sob}$ & Read-only & $n_\mathrm{lines} \times n_\mathrm{shells} \times 8$~B \\
Transition probs & Read-only & $n_\mathrm{trans} \times n_\mathrm{shells} \times 8$~B \\
Shell geometry & Read-only & $n_\mathrm{shells} \times 4 \times 8$~B \\
RNG states & Read/write & $N_\mathrm{pkt} \times 4 \times 8$~B \\
$j$, $\overline{\nu}$ estimators & Atomic write & $n_\mathrm{shells} \times 2 \times 8$~B \\
Output arrays & Write-only & $N_\mathrm{pkt} \times 3 \times 8$~B \\
\bottomrule
\end{tabular}
\end{table}

Total GPU memory: approximately 2~GB for a typical run.

\section{Kernel Launch Configuration}\index{CUDA!Kernel Launch}

\begin{lstlisting}[style=cudastyle,caption={Kernel launch}]
int threads_per_block = 256;
int blocks = (n_packets + threads_per_block - 1)
             / threads_per_block;
// Max blocks: 131072 (was 1024 -- critical bug #13)
transport_kernel<<<blocks, threads_per_block>>>(...);
\end{lstlisting}

\begin{important}
The original code had \texttt{CUDA\_MAX\_BLOCKS = 1024}, limiting execution to 262K packets regardless of $N_\mathrm{packets}$. For 2M packets, only 13\% executed, causing $j_\mathrm{estimator}$ to be 76$\times$ too low. This was the single largest GPU bug (Task \#13).
\end{important}

\section{Random Number Generation}\index{CUDA!RNG}

Each thread uses an independent \textbf{xoshiro256**} generator with 256 bits of state (4 $\times$ \texttt{uint64}). Seeds are derived from the packet index via SplitMix64:

\begin{lstlisting}[style=cudastyle,caption={Per-thread RNG initialization}]
__device__ void init_rng(uint64_t *state, uint64_t seed) {
    // SplitMix64 to expand seed into 4 state words
    state[0] = splitmix64(&seed);
    state[1] = splitmix64(&seed);
    state[2] = splitmix64(&seed);
    state[3] = splitmix64(&seed);
}
\end{lstlisting}

\section{Atomic Estimator Updates}\index{CUDA!Atomic Operations}

The $j$ and $\overline{\nu}$ estimators are updated using CUDA \texttt{atomicAdd}:

\begin{lstlisting}[style=cudastyle,caption={Estimator accumulation on GPU}]
__device__ void update_estimators(
    double *d_j_est, double *d_nu_bar_est,
    int shell_id, double comov_energy,
    double comov_nu, double distance)
{
    atomicAdd(&d_j_est[shell_id],
              comov_energy * distance);
    atomicAdd(&d_nu_bar_est[shell_id],
              comov_energy * distance * comov_nu);
}
\end{lstlisting}

Since there are only $n_\mathrm{shells} = 30$ accumulation targets, contention is manageable.

\section{Performance}\index{CUDA!Performance}

\begin{table}[h]
\centering
\caption{CPU vs GPU performance (NVIDIA RTX 5000 Ada, sm\_89).}
\begin{tabular}{lrrrr}
\toprule
\textbf{$N_\mathrm{packets}$} & \textbf{CPU (1 core)} & \textbf{CPU (OMP64)} & \textbf{GPU} & \textbf{Speedup} \\
\midrule
20,000 & 0.7\,s & 0.1\,s & 0.08\,s & $9\times$ \\
200,000 & 7.2\,s & 1.1\,s & 0.73\,s & $10\times$ \\
2,000,000 & 72\,s & 11\,s & 7.3\,s & $10\times$ \\
20,000,000 & 720\,s & 110\,s & 73\,s & $10\times$ \\
\bottomrule
\end{tabular}
\end{table}

\begin{remark}[Statistical Accuracy]
GPU and CPU produce statistically identical results. At 200K packets: $W$ error $1.06\%$, $T_\mathrm{rad}$ error $0.58\%$ (relative to TARDIS reference). The scaling follows $\sigma \propto N^{-0.35}$ to $N^{-0.40}$, close to Poisson ($N^{-0.5}$).
\end{remark}

\section{Resolved GPU Bugs}\index{CUDA!Bug Fixes}

Four critical bugs were identified and fixed during development:

\begin{enumerate}
\item \textbf{MAX\_BLOCKS = 1024}: Only 262K threads could launch. Fixed to 131072.
\item \textbf{Shared memory race}: \texttt{\_\_shared\_\_ ShellCache} shared by all 256 threads, but only thread 0 loaded data. Fixed: use L1-cached global memory.
\item \textbf{Counter accumulation}: Escape/reabsorb counters not reset between iterations. Fixed: explicit reset in \texttt{cuda\_reset\_estimators()}.
\item \textbf{Boundary sticking}: Packets land exactly on shell boundaries due to floating-point precision. Fixed: explicit nudge by $10^{-10} \times \Delta r$.
\end{enumerate}


%========================================================================================
%	PART III: USAGE & APPLICATIONS
%========================================================================================

\part{Usage \& Applications}

%----------------------------------------------------------------------------------------
%	CHAPTER 11: Quick Start
%----------------------------------------------------------------------------------------

\chapter{Installation \& Quick Start}\index{Installation}

\section{Prerequisites}

\begin{table}[h]
\centering
\caption{System requirements.}
\begin{tabular}{ll}
\toprule
\textbf{Component} & \textbf{Requirement} \\
\midrule
C Compiler & GCC $\geq$ 9.0 (C11 support) \\
CUDA (optional) & Toolkit $\geq$ 12.0, compute capability $\geq$ 7.0 \\
HDF5 (optional) & \texttt{libhdf5-dev} for atomic data loading \\
Memory & $\geq$ 4~GB RAM (CPU), $\geq$ 4~GB VRAM (GPU) \\
\bottomrule
\end{tabular}
\end{table}

\section{Step-by-Step Setup}

\begin{lstlisting}[style=bashstyle,caption={Complete setup procedure}]
# Clone the repository
git clone git@github.com:kjhan0606/lumina-sn.git
cd lumina-sn

# Build CPU version
make

# (Optional) Build GPU version
make cuda

# Verify with a quick test (1000 packets, 5 iterations)
./lumina tardis_reference 1000 5

# Production run (200K packets, 20 iterations)
./lumina tardis_reference 200000 20

# Check output
head lumina_spectrum.csv
\end{lstlisting}

\section{Input Directory Structure}\index{Input Files}

LUMINA expects a reference data directory (default: \texttt{data/tardis\_reference/}) containing:

\begin{lstlisting}[style=bashstyle,caption={Required input files}]
data/tardis_reference/
  config.json                # Simulation parameters
  geometry.csv               # Shell radii and velocities
  density.csv                # Mass density per shell
  abundances.csv             # Element mass fractions
  electron_densities.csv     # Initial electron densities
  plasma_state.csv           # Initial W, T_rad per shell
  line_list.csv              # Atomic line data
  tau_sobolev.npy            # Reference optical depths
  transition_probabilities.npy
  macro_atom_data.csv
  macro_atom_references.csv
  line2macro_level_upper.npy
  levels.csv                 # Energy levels
  ionization_energies.csv
  zeta_ions.csv
  zeta_temps.csv
  zeta_data.npy
  atom_masses.csv
\end{lstlisting}

\section{Output Files}\index{Output Files}

\begin{table}[h]
\centering
\caption{Output files produced by LUMINA.}
\begin{tabular}{ll}
\toprule
\textbf{File} & \textbf{Contents} \\
\midrule
\texttt{lumina\_spectrum.csv} & $\lambda$ (\AA) vs $L_\lambda$ (erg/s/cm) \\
\texttt{lumina\_plasma\_state.csv} & Final $W$, $T_\mathrm{rad}$ per shell \\
\texttt{lumina\_tau\_validation.csv} & $\tau_\mathrm{Sob}$ at shell 0 (debug) \\
\bottomrule
\end{tabular}
\end{table}


%----------------------------------------------------------------------------------------
%	CHAPTER 12: The Ejecta Model
%----------------------------------------------------------------------------------------

\chapter{The Ejecta Model}\index{Ejecta Model}

\section{Three-Zone Composition}\index{Ejecta Model!Three-Zone}

LUMINA uses a three-zone abundance structure motivated by SN~Ia nucleosynthesis:

\begin{table}[h]
\centering
\caption{Default three-zone composition model.}
\begin{tabular}{lcccccccc}
\toprule
\textbf{Zone} & \textbf{Fe} & \textbf{Si} & \textbf{S} & \textbf{Ca} & \textbf{Co} & \textbf{Ni} & \textbf{C} & \textbf{O} \\
\midrule
Core ($v < v_\mathrm{core}$) & \textit{free} & 0.05 & 0.05 & 0.03 & 0.05 & \textit{free} & 0.02 & filler \\
Wall ($v_\mathrm{core}$--$v_\mathrm{wall}$) & \textit{free} & \textit{free} & 0.05 & 0.03 & 0.05 & \textit{free} & 0.02 & filler \\
Outer ($v > v_\mathrm{wall}$) & \textit{free} & 0.02 & 0.02 & 0.01 & 0.05 & \textit{free} & 0.02 & filler \\
\bottomrule
\end{tabular}
\end{table}

\noindent ``Filler'' means oxygen fills the remaining mass fraction to ensure $\sum X_i = 1$.

\begin{important}
Oxygen is the correct filler element for the outer zone because it has very few optical absorption lines and is essentially transparent. Using Fe/Ni/S as fillers creates massive line blanketing ($> 10^6$ active lines) that produces an artificial pseudo-photosphere (Task \#063).
\end{important}

\section{Broken Power-Law Density}\index{Ejecta Model!Density Profile}

The density profile is a broken power law:
\begin{equation}
\rho(v) = \begin{cases}
\rho_0 \left(\dfrac{v}{v_\mathrm{inner}}\right)^{n_\mathrm{inner}} & v < v_\mathrm{break} \\[10pt]
\rho_\mathrm{break} \left(\dfrac{v}{v_\mathrm{break}}\right)^{n_\mathrm{outer}} & v \geq v_\mathrm{break}
\end{cases}
\end{equation}
where $\rho_\mathrm{break} = \rho_0 (v_\mathrm{break}/v_\mathrm{inner})^{n_\mathrm{inner}}$ ensures continuity at $v_\mathrm{break}$.

Typical values: $n_\mathrm{inner} \approx -7$, $n_\mathrm{outer} \approx -10$.

\section{Physical Parameter Space}\index{Ejecta Model!Parameter Space}

LUMINA-ML (the machine learning emulator companion) uses a 15-dimensional parameter space:

\begin{table}[h]
\centering
\caption{Full 15D parameter space with ranges.}
\label{tab:params_15d}
\small
\begin{tabular}{clccl}
\toprule
\textbf{\#} & \textbf{Parameter} & \textbf{Min} & \textbf{Max} & \textbf{Description} \\
\midrule
1 & $\log L$ & 42.50 & 43.50 & Luminosity [erg/s] \\
2 & $v_\mathrm{inner}$ & 7000 & 15000 & Photosphere velocity [km/s] \\
3 & $\log\rho_0$ & $-14.0$ & $-12.3$ & Reference density [g/cm$^3$] \\
4 & $n_\mathrm{inner}$ & $-10$ & $-4$ & Inner density exponent \\
5 & $T_e/T_\mathrm{rad}$ & 0.7 & 1.0 & Temperature ratio \\
6 & $v_\mathrm{core}$ & 9000 & 17000 & Core/wall boundary [km/s] \\
7 & $v_\mathrm{wall}$ & 12000 & 24000 & Wall/outer boundary [km/s] \\
8 & $X_\mathrm{Fe,core}$ & 0.05 & 0.85 & Core iron abundance \\
9 & $X_\mathrm{Si,wall}$ & 0.05 & 0.75 & Wall silicon abundance \\
10 & $v_\mathrm{break}$ & 10000 & 22000 & Density break velocity [km/s] \\
11 & $n_\mathrm{outer}$ & $-14$ & $-4$ & Outer density exponent \\
12 & $t_\mathrm{exp}$ & 10 & 28 & Time since explosion [days] \\
13 & $X_\mathrm{Fe,wall}$ & 0.001 & 0.50 & Wall iron contamination \\
14 & $X_\mathrm{Ni}$ & 0.005 & 0.25 & Nickel abundance (all zones) \\
15 & $X_\mathrm{Fe,outer}$ & 0.001 & 0.15 & Outer iron abundance \\
\bottomrule
\end{tabular}
\end{table}


%----------------------------------------------------------------------------------------
%	CHAPTER 13: Parameter Fitting
%----------------------------------------------------------------------------------------

\chapter{Parameter Fitting}\index{Parameter Fitting}

\section{Fitting Strategy}

LUMINA includes a multi-phase parameter search framework (\texttt{scripts/fit\_parameter\_search.py}) that combines Latin Hypercube Sampling with progressive refinement.

\subsection{Phase 1: Coarse Exploration}
\begin{itemize}
\item 200 Latin Hypercube samples across full parameter space
\item 20K packets $\times$ 5 iterations (fast, $\sim$5~s per model)
\item Score by feature-weighted RMS
\item Select top-20 candidates
\end{itemize}

\subsection{Phase 2: Refinement}
\begin{itemize}
\item Top-20 candidates re-simulated with 100K packets $\times$ 10 iterations
\item Better statistics reduce Monte Carlo noise
\item Select top-3
\end{itemize}

\subsection{Phase 3: Production}
\begin{itemize}
\item Top-3 candidates with 500K packets $\times$ 20 iterations
\item Highest-fidelity spectra
\item Final selection based on composite score
\end{itemize}

\section{Objective Function}\index{Parameter Fitting!Objective Function}

The composite scoring function includes:
\begin{equation}
\text{Score} = \text{RMS}_\mathrm{spec} + 0.5\,|\Delta d_\mathrm{Si\,II}| + 0.2\,|\Delta \log v_\mathrm{Si\,II}| + 0.1\,|\Delta\lambda_\mathrm{min}|
\end{equation}
where:
\begin{itemize}
\item $\text{RMS}_\mathrm{spec}$: Spectral RMS over 5000--8000~\AA
\item $\Delta d_\mathrm{Si\,II}$: Si~\textsc{ii} 6355 absorption depth error
\item $\Delta \log v_\mathrm{Si\,II}$: Si~\textsc{ii} velocity error (log scale)
\item $\Delta\lambda_\mathrm{min}$: Si~\textsc{ii} trough wavelength error
\end{itemize}


%----------------------------------------------------------------------------------------
%	CHAPTER 14: Physical Constants
%----------------------------------------------------------------------------------------

\chapter{Physical Constants \& Reference Values}\index{Physical Constants}

\begin{table}[h]
\centering
\caption{Physical constants used in LUMINA (CGS).}
\begin{tabular}{llr}
\toprule
\textbf{Symbol} & \textbf{Description} & \textbf{Value} \\
\midrule
$c$ & Speed of light & $2.99792458 \times 10^{10}$~cm/s \\
$h$ & Planck constant & $6.62607015 \times 10^{-27}$~erg$\cdot$s \\
$k_B$ & Boltzmann constant & $1.380649 \times 10^{-16}$~erg/K \\
$\sigma_\mathrm{SB}$ & Stefan--Boltzmann & $5.670374 \times 10^{-5}$~erg/cm$^2$/s/K$^4$ \\
$\sigma_T$ & Thomson cross-section & $6.6525 \times 10^{-25}$~cm$^2$ \\
$m_e$ & Electron mass & $9.10938 \times 10^{-28}$~g \\
$e$ & Electron charge & $4.80321 \times 10^{-10}$~esu \\
$\pi e^2/(m_e c)$ & Sobolev coefficient & $2.6540 \times 10^{-2}$~cm$^2$/s \\
$T_\mathrm{rad,const}$ & $T_\mathrm{rad}$ estimator constant & $1.2523 \times 10^{-11}$~K$\cdot$s \\
\bottomrule
\end{tabular}
\end{table}


%----------------------------------------------------------------------------------------
%	CHAPTER 15: Comparison with Other Codes
%----------------------------------------------------------------------------------------

\chapter{Comparison with Other Radiative Transfer Codes}\index{Code Comparison}
\label{ch:comparison}

Numerous radiative transfer codes exist for modelling supernova spectra and light curves.
This chapter places LUMINA-SN in context by comparing its design philosophy, physics scope,
and computational performance against the most widely used alternatives.

\section{Overview}

Table~\ref{tab:code_comparison} summarises the key features of each code.

\begin{table}[h]
\centering
\caption{Comparison of supernova radiative transfer codes.}
\label{tab:code_comparison}
\small
\begin{tabular}{lcccccc}
\toprule
\textbf{Feature} & \textbf{LUMINA} & \textbf{TARDIS} & \textbf{SYN++} & \textbf{SEDONA} & \textbf{ARTIS} & \textbf{CMFGEN} \\
\midrule
RT method       & MC      & MC      & Param.  & MC      & MC      & CMF-ALI \\
Geometry        & 1D      & 1D      & 1D      & 3D      & 3D      & 1D \\
NLTE            & Full$^a$& Dilute  & LTE     & LTE/NLTE& Full    & Full \\
Macro-atom      & Yes     & Yes     & No      & Partial & Yes     & --- \\
GPU accel.      & CUDA    & No      & No      & No      & No      & No \\
Time-dep.       & No      & No      & No      & Yes     & Yes     & No \\
Language        & C/CUDA  & Py/Cy   & C++     & C++     & C++     & Fortran \\
\bottomrule
\end{tabular}

\vspace{0.3em}
\footnotesize{$^a$Full statistical equilibrium for Si, Ca, Fe, S (2017 levels); other species use the nebular approximation.}
\end{table}

\section{TARDIS}\index{Code Comparison!TARDIS}

TARDIS \citep{kerzendorf2014} is the direct ancestor of LUMINA-SN.  Both codes implement the same Monte Carlo radiative transfer formalism in 1D homologous expansion with the macro-atom method of \citet{lucy2002,lucy2003}.

\begin{ocrebox}
\textbf{LUMINA advantages over TARDIS:}
\begin{itemize}
\item \textbf{GPU acceleration}: CUDA transport kernel provides $\sim$10$\times$ speedup over TARDIS's Cython implementation (200K packets: 0.7\,s vs 7.2\,s).
\item \textbf{Full NLTE solver}: Statistical equilibrium with radiative + collisional rates for Si/Ca/Fe/S, solved via cuBLAS batched LU on GPU.  TARDIS uses the dilute-LTE (nebular) approximation for all species.
\item \textbf{Minimal dependencies}: Pure C99/CUDA binary with no Python runtime, enabling HPC deployment without Conda environments.
\item \textbf{Integrated ML pipeline}: Latin Hypercube sampling + neural emulator + SBI/MCMC inference chain for automated parameter fitting.
\end{itemize}
\end{ocrebox}

\begin{bluebox}
\textbf{TARDIS advantages over LUMINA:}
\begin{itemize}
\item \textbf{Broader scope}: Models CC-SNe, kilonovae (with lanthanide opacities), and other transients.
\item \textbf{Larger community}: 40+ contributors, comprehensive documentation, active development.
\item \textbf{Flexible plasma module}: Pluggable ionization/excitation solvers via the \texttt{plasma} framework.
\item \textbf{Deeper Si~II trough}: TARDIS achieves 93\% absorption depth vs LUMINA's 75--83\%, likely due to subtle differences in the macro-atom source function implementation.
\end{itemize}
\end{bluebox}

\section{SYN++}\index{Code Comparison!SYN++}

SYN++ \citep{thomas2011} is a parametric spectrum synthesis tool descended from SYNOW.  It assumes a sharp photosphere emitting a blackbody, with resonance-scattering line profiles computed in the Sobolev approximation.  Each ion is characterised by a minimum velocity, optical depth, and excitation temperature.

\begin{itemize}
\item \textbf{LUMINA advantage}: Self-consistent radiation field---ionization balance, dilution factors, and level populations are computed from the Monte Carlo simulation rather than input by hand.  Fluorescence and macro-atom redistribution produce realistic P~Cygni profiles with emission components.
\item \textbf{SYN++ advantage}: Extremely fast (seconds per model), making it ideal for rapid line identification, spectral classification, and interactive fitting.  Its simplicity is a strength for survey-scale work.
\end{itemize}

\noindent SYN++ and LUMINA serve different purposes: SYN++ is a \emph{fitting tool} for quick diagnostics, while LUMINA is a \emph{physics code} for quantitative abundance and density studies.

\section{SEDONA}\index{Code Comparison!SEDONA}

SEDONA \citep{kasen2006} is a multi-dimensional, time-dependent Monte Carlo code designed to compute both spectra and light curves from first principles.

\begin{itemize}
\item \textbf{LUMINA advantage}: GPU acceleration ($\sim$10$\times$) and NLTE solver for key diagnostic ions.  LUMINA's ML fitting pipeline enables automated parameter estimation, whereas SEDONA is typically run on pre-computed explosion models.
\item \textbf{SEDONA advantage}: Full 3D geometry with time-dependent radiation transport, $\gamma$-ray deposition from $^{56}$Ni decay, and multi-epoch light curve computation.  It can model asymmetric explosions, viewing-angle effects, and nebular-phase spectra.
\end{itemize}

\noindent SEDONA is an ``explosion-to-observables'' code that starts from hydrodynamic models, while LUMINA is optimised for single-epoch spectral fitting against observations.

\section{ARTIS}\index{Code Comparison!ARTIS}

ARTIS \citep{sim2007,kromer2009} is a 3D time-dependent Monte Carlo code with full NLTE, developed primarily for SN~Ia.  It incorporates macro-atom physics and $\gamma$-ray transport.

\begin{itemize}
\item \textbf{LUMINA advantage}: GPU acceleration and integrated parameter search.  A single-epoch LUMINA model runs in $\sim$14\,s on GPU, enabling 5,000-model grid searches in $\sim$19\,hours.  ARTIS runs are typically CPU-only and take hours per model.
\item \textbf{ARTIS advantage}: Full 3D geometry, time dependence, complete NLTE for all species, and $\gamma$-ray energy deposition.  ARTIS can model both photospheric and nebular phase spectra from the same explosion model.
\end{itemize}

\section{CMFGEN}\index{Code Comparison!CMFGEN}

CMFGEN \citep{hillier1998} solves the radiative transfer and statistical equilibrium equations simultaneously in the comoving frame using the accelerated lambda iteration (ALI) method.  It treats millions of lines in full NLTE.

\begin{itemize}
\item \textbf{LUMINA advantage}: Monte Carlo naturally handles line overlap and fluorescence without explicit frequency-by-frequency integration.  GPU acceleration makes large parameter surveys feasible (thousands of models per day vs one CMFGEN model per several hours).
\item \textbf{CMFGEN advantage}: Full NLTE for \emph{all} species simultaneously (not just 4 elements), self-consistent radiation--matter coupling via ALI, wind clumping, and decades of validation across diverse astrophysical objects (OB stars, WR stars, LBVs, SN~Ia, CC-SNe).  CMFGEN represents the gold standard for spectroscopic precision.
\end{itemize}

\section{PHOENIX}\index{Code Comparison!PHOENIX}

PHOENIX \citep{hauschildt1997} is a general-purpose NLTE atmosphere code applicable to an extraordinarily wide range of objects: stars, brown dwarfs, exoplanet atmospheres, novae, and supernovae.

\begin{itemize}
\item \textbf{LUMINA advantage}: SN~Ia-specific optimisation, GPU acceleration, and lightweight codebase ($\sim$5K lines vs $\sim$200K).
\item \textbf{PHOENIX advantage}: Broadest applicability of any radiative transfer code, full NLTE with the most extensive atomic database, and 30+ years of validation.
\end{itemize}

\section{Summary: LUMINA's Niche}\index{Code Comparison!Summary}

LUMINA-SN occupies a unique position in the landscape of supernova radiative transfer codes:

\begin{important}
\textbf{LUMINA = TARDIS physics $+$ GPU acceleration $+$ NLTE $+$ ML fitting pipeline.}

No other code combines Monte Carlo macro-atom transport with GPU acceleration and an integrated Bayesian inference framework.  This makes LUMINA the tool of choice for \textbf{large-scale, automated spectral fitting of SN~Ia} at photospheric epochs.
\end{important}

\noindent The trade-offs are clear: LUMINA sacrifices multi-dimensionality (vs SEDONA, ARTIS), time dependence (vs SEDONA, ARTIS), and universal NLTE coverage (vs CMFGEN, PHOENIX) in exchange for \textbf{speed} and \textbf{automation}.  For the specific problem of fitting observed SN~Ia spectra near maximum light, this trade-off is highly favourable.

\begin{table}[h]
\centering
\caption{Approximate single-model execution times (200K packets, 20 iterations for MC codes).}
\label{tab:runtime}
\begin{tabular}{lrl}
\toprule
\textbf{Code} & \textbf{Time} & \textbf{Hardware} \\
\midrule
SYN++    & $\sim$1\,s     & 1 CPU core \\
LUMINA   & $\sim$14\,s    & 1 GPU (RTX 5000 Ada) \\
TARDIS   & $\sim$60--120\,s & 1 CPU core (Cython) \\
ARTIS    & $\sim$hours    & MPI cluster \\
SEDONA   & $\sim$hours    & MPI cluster \\
CMFGEN   & $\sim$hours    & 1--8 CPU cores \\
PHOENIX  & $\sim$hours    & MPI cluster \\
\bottomrule
\end{tabular}
\end{table}

Table~\ref{tab:nlte_scope} clarifies the distinction between ``full NLTE'' implementations.

\begin{table}[h]
\centering
\caption{NLTE implementation scope across codes.}
\label{tab:nlte_scope}
\begin{tabular}{lll}
\toprule
\textbf{Code} & \textbf{NLTE physics} & \textbf{Species coverage} \\
\midrule
CMFGEN  & Full stat.\ equil.\ + ALI & All species (millions of transitions) \\
PHOENIX & Full stat.\ equil.\ + ALI & All species \\
ARTIS   & Full stat.\ equil.\ (MC) & All species \\
LUMINA  & Full stat.\ equil.\ (MC + $J_\nu$) & Si, Ca, Fe, S (2017 levels) \\
TARDIS  & Dilute-LTE (nebular approx.) & N/A (no NLTE solver) \\
SYN++   & LTE (Boltzmann) & N/A \\
SEDONA  & Mixed (LTE + optional NLTE) & Configuration-dependent \\
\bottomrule
\end{tabular}
\end{table}

As shown in Table~\ref{tab:nlte_scope}, LUMINA's NLTE solver applies the \emph{same physics}---full statistical equilibrium with radiative and collisional bound--bound rates, photoionisation (Kramers), and recombination (Milne)---as CMFGEN and PHOENIX.  The difference is purely in \textbf{species coverage}: LUMINA solves NLTE for the four elements most critical to SN~Ia optical diagnostics, while CMFGEN and PHOENIX solve it for all species simultaneously.  For SN~Ia photospheric spectra, the optical depth is overwhelmingly dominated by Si, Ca, Fe, and S lines, so this is a well-motivated approximation.


%----------------------------------------------------------------------------------------
%	BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\chapter*{Bibliography}
\addcontentsline{toc}{chapter}{\textcolor{ocre}{Bibliography}}
\printbibliography[heading=none]

%----------------------------------------------------------------------------------------
%	INDEX
%----------------------------------------------------------------------------------------

\cleardoublepage
\phantomsection
\setlength{\columnsep}{0.75cm}
\addcontentsline{toc}{chapter}{\textcolor{ocre}{Index}}
\printindex

\end{document}
